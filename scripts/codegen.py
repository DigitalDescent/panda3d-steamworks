#!/usr/bin/env python3
"""
Code generator: reads steam_api.json and produces Panda3D-compatible
C++ wrapper classes (.h / .cpp) for the configured Steamworks interfaces.

Usage:
    ppython scripts/codegen.py            # generate into source/
    ppython scripts/codegen.py --check    # exit 1 if files are out of date

This script is also called automatically by setup.py before the CMake build.
"""

from __future__ import print_function

import json
import os
import re
import sys
import textwrap

# ---------------------------------------------------------------------------
# Make sure we can import the sibling config module regardless of CWD.
# ---------------------------------------------------------------------------
_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
_ROOT_DIR = os.path.normpath(os.path.join(_SCRIPT_DIR, ".."))

if _SCRIPT_DIR not in sys.path:
    sys.path.insert(0, _SCRIPT_DIR)

import codegen_config as cfg  # noqa: E402
import codegen_callbacks as cbgen  # noqa: E402

# ---------------------------------------------------------------------------
# Auto-generated file banner
# ---------------------------------------------------------------------------
_GENERATED_BANNER = (
    "// ======================================================================\n"
    "// AUTO-GENERATED by scripts/codegen.py - DO NOT EDIT BY HAND.\n"
    "// Re-generate with:  ppython scripts/codegen.py\n"
    "// ======================================================================"
)


# ========================================================================
# Name helpers
# ========================================================================

def _camel_to_snake(name):
    """Convert CamelCase / PascalCase to snake_case, keeping acronyms grouped.

    Examples:
        GetDLCCount   -> get_dlc_count
        BIsSubscribed -> b_is_subscribed  (caller strips B prefix separately)
        GetAppBuildId -> get_app_build_id
    """
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z\d])([A-Z])", r"\1_\2", s)
    return s.lower()


def _strip_hungarian(name):
    """Strip common Hungarian-notation prefixes from parameter names.

    Only strips when the remainder starts with an uppercase letter, so real
    words like ``count`` or ``name`` are left intact.
    """
    # Order matters — try longer prefixes first.
    prefixes = [
        "ppch", "ppsz",
        "pch", "psz", "pfn", "pfl", "pun", "pub", "pvec",
        "rgb", "rg",
        "pp", "pb", "pn", "pi", "pf",
        "fl", "un", "ul",
        "cb", "cch", "cub",
        "sz", "ch", "fn",
        "p", "n", "b", "e", "i", "c", "f",
    ]
    for pfx in prefixes:
        if name.startswith(pfx) and len(name) > len(pfx) and name[len(pfx)].isupper():
            return name[len(pfx):]
    return name


def steam_method_to_snake(method_name, return_type):
    """Convert a Steam method name to a Panda3D-style snake_case name.

    Strips the ``B`` prefix that Steamworks uses on boolean queries.
    """
    name = method_name
    if (return_type == "bool"
            and name.startswith("B")
            and len(name) > 1
            and name[1].isupper()):
        name = name[1:]
    return _camel_to_snake(name)


# C++ reserved keywords that cannot be used as parameter names
_CPP_KEYWORDS = frozenset({
    "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand",
    "bitor", "bool", "break", "case", "catch", "char", "char8_t",
    "char16_t", "char32_t", "class", "compl", "concept", "const",
    "consteval", "constexpr", "constinit", "const_cast", "continue",
    "co_await", "co_return", "co_yield", "decltype", "default", "delete",
    "do", "double", "dynamic_cast", "else", "enum", "explicit", "export",
    "extern", "false", "float", "for", "friend", "goto", "if", "inline",
    "int", "long", "mutable", "namespace", "new", "noexcept", "not",
    "not_eq", "nullptr", "operator", "or", "or_eq", "private", "protected",
    "public", "register", "reinterpret_cast", "requires", "return",
    "short", "signed", "sizeof", "static", "static_assert", "static_cast",
    "struct", "switch", "template", "this", "thread_local", "throw",
    "true", "try", "typedef", "typeid", "typename", "union", "unsigned",
    "using", "virtual", "void", "volatile", "wchar_t", "while", "xor",
    "xor_eq",
})


def steam_param_to_snake(param_name):
    """Convert a Steam parameter name to snake_case, stripping Hungarian."""
    name = _camel_to_snake(_strip_hungarian(param_name))
    if name in _CPP_KEYWORDS:
        name = name + "_val"
    return name


# ========================================================================
# Type resolution
# ========================================================================

def _build_typedef_map(api_data):
    """Build a dict of Steam typedef name -> underlying type."""
    result = {}
    for td in api_data.get("typedefs", []):
        result[td["typedef"]] = td["type"]
    return result


def _build_enum_set(api_data):
    """Build a set of all known enum type names."""
    result = set()
    for e in api_data.get("enums", []):
        result.add(e["enumname"])
    # Also grab nested enums inside callback_structs / structs
    for section in ("callback_structs", "structs"):
        for s in api_data.get(section, []):
            for e in s.get("enums", []):
                result.add(e.get("fqname", e["enumname"]))
                result.add(e["enumname"])
    return result


def resolve_return_type(steam_type, typedefs, enums):
    """Resolve a Steam return type to (cpp_type, default_value, handling) or None.

    Returns None if the method should be skipped.
    """
    st = steam_type.strip()

    # Direct lookup
    if st in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[st]

    # Typedef resolution (one level)
    if st in typedefs and typedefs[st] in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[typedefs[st]]

    # Enum -> int
    if st in enums:
        return ("int", "0", None)

    return None  # unknown -> skip


def resolve_param_type(steam_type, typedefs, enums):
    """Resolve a Steam parameter type to (cpp_type, call_transform) or None."""
    st = steam_type.strip()

    if st in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[st]

    if st in typedefs and typedefs[st] in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[typedefs[st]]

    if st in enums:
        return ("int", "enum_cast:{}".format(st))

    return None  # unknown -> skip


# ========================================================================
# Method classification
# ========================================================================

# Method kinds
SIMPLE = "simple"           # No special handling needed
STRING_BUFFER = "buffer"    # Has char*/size output pairs -> return std::string
SKIP = "skip"               # Cannot auto-generate
ASYNC = "async"             # SteamAPICall_t return -> CCallResult-based async wrapper


def classify_method(method, typedefs, enums):
    """Classify a method as SIMPLE, STRING_BUFFER, ASYNC, or SKIP.

    Returns (kind, buffer_pairs) where buffer_pairs is a list of
    (char_param_index, size_param_index) tuples for STRING_BUFFER methods.
    For ASYNC methods, buffer_pairs is always empty.
    """
    ret_type = method["returntype"].strip()
    params = method.get("params", [])

    # --- Async methods (SteamAPICall_t) ---
    if ret_type == "SteamAPICall_t":
        if not getattr(cfg, 'ENABLE_ASYNC_METHODS', False):
            return SKIP, []
        callresult = method.get("callresult", "")
        if not callresult:
            return SKIP, []
        skip_cb = getattr(cfg, 'SKIP_CALLBACK_STRUCTS', set())
        if callresult in skip_cb:
            return SKIP, []
        # Verify all params are resolvable and no output pointers
        for p in params:
            pt = p["paramtype"].strip()
            if pt.endswith("*") and not pt.startswith("const "):
                return SKIP, []
            if resolve_param_type(pt, typedefs, enums) is None:
                return SKIP, []
        return ASYNC, []

    # --- Sync methods ---
    if resolve_return_type(ret_type, typedefs, enums) is None:
        return SKIP, []

    # Scan for pointer params
    buffer_pairs = []       # (char_idx, size_idx)
    other_pointers = []     # indices of non-buffer pointer params

    i = 0
    while i < len(params):
        pt = params[i]["paramtype"].strip()

        if pt == "char *":
            # Check if next param is a buffer size
            if (i + 1 < len(params)
                    and params[i + 1]["paramtype"].strip() in ("int", "uint32", "int32")):
                buffer_pairs.append((i, i + 1))
                i += 2
                continue
            else:
                other_pointers.append(i)
        elif pt.endswith("*") and not pt.startswith("const "):
            other_pointers.append(i)

        i += 1

    if other_pointers:
        return SKIP, []

    # Check that all non-buffer params can be resolved
    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    for idx, p in enumerate(params):
        if idx in skip_indices:
            continue
        if resolve_param_type(p["paramtype"], typedefs, enums) is None:
            return SKIP, []

    if buffer_pairs:
        return STRING_BUFFER, buffer_pairs
    return SIMPLE, []


# ========================================================================
# Code generation helpers
# ========================================================================

def _needs_string_include(methods_info):
    """Check if any generated method uses std::string."""
    for _method, _kind, _bpairs, ret_info, _wrapper_params in methods_info:
        if ret_info and ret_info[0] == "std::string":
            return True
        for _pname, ptype, _ptransform in _wrapper_params:
            if ptype == "const std::string &":
                return True
    return False


def _has_async_methods(methods_info):
    """Check if any method is ASYNC (needs PyObject / steamPython.h)."""
    return any(kind == ASYNC for _, kind, _, _, _ in methods_info)


def _make_wrapper_params(method, buffer_pairs, typedefs, enums):
    """Build the list of (param_name, cpp_type, call_transform) for wrapper.

    Buffer-pair params are excluded.
    """
    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    result = []
    for idx, p in enumerate(method.get("params", [])):
        if idx in skip_indices:
            continue
        cpp_type, transform = resolve_param_type(p["paramtype"], typedefs, enums)
        pname = steam_param_to_snake(p["paramname"])
        result.append((pname, cpp_type, transform))
    return result


def _format_header_param(pname, ptype):
    """Format a single parameter for a header declaration."""
    return "{} {}".format(ptype, pname)


def _format_call_arg(pname, transform):
    """Format a single argument for calling into the Steam API."""
    if transform == "c_str":
        return "{}.c_str()".format(pname)
    if transform == "steamid_from":
        return "CSteamID({})".format(pname)
    if transform and transform.startswith("enum_cast:"):
        enum_type = transform[len("enum_cast:"):]
        return "static_cast<{}>({})".format(enum_type, pname)
    return pname


# ========================================================================
# Header generation
# ========================================================================

def generate_header(iface_name, iface_data, iface_cfg, methods_info):
    """Generate the .h file content for a single interface wrapper."""
    class_name = iface_cfg["class_name"]
    description = iface_cfg.get("description", "Wrapper around {}.".format(iface_name))
    needs_string = _needs_string_include(methods_info)
    has_async = _has_async_methods(methods_info)

    lines = []
    lines.append(_GENERATED_BANNER)
    lines.append("")
    lines.append("#pragma once")
    lines.append("")
    lines.append('#include "pandabase.h"')
    if has_async:
        lines.append('#include "steamPython.h"')
    if needs_string:
        lines.append("#include <string>")
    lines.append("")

    # Class comment
    lines.append("/" * 68)
    lines.append("//       Class : {}".format(class_name))
    desc_lines = description.split("\n")
    lines.append("// Description : {}".format(desc_lines[0]))
    for dl in desc_lines[1:]:
        lines.append("//{}".format(dl))
    lines.append("/" * 68)
    lines.append("class EXPORT_CLASS {} {{".format(class_name))
    lines.append("PUBLISHED:")

    # init / shutdown (optional)
    if iface_cfg.get("include_api_lifecycle"):
        lines.append("  // Initialization - must be called before any other Steam methods.")
        lines.append("  // Returns true if SteamAPI was initialized successfully.")
        lines.append("  static bool init();")
        lines.append("  static void shutdown();")
        lines.append("")

    # Generated methods
    for method, kind, bpairs, ret_info, wrapper_params in methods_info:
        snake = steam_method_to_snake(method["methodname"], method["returntype"])

        if kind == ASYNC:
            ret_cpp = "unsigned long long"
            callresult = method.get("callresult", "")
            lines.append("  // Async: callback receives dict with result fields.")
            lines.append("  // Returns call handle (0 on failure).")
        elif kind == STRING_BUFFER:
            ret_cpp = "std::string"
        else:
            ret_cpp = ret_info[0]

        param_str = ", ".join(
            _format_header_param(pn, pt) for pn, pt, _ in wrapper_params
        )
        # Async methods get an extra PyObject *callback parameter
        if kind == ASYNC:
            if param_str:
                param_str += ", PyObject *callback"
            else:
                param_str = "PyObject *callback"
        lines.append("  static {} {}({});".format(ret_cpp, snake, param_str))

    lines.append("")
    lines.append("private:")
    lines.append("  {}() = delete;".format(class_name))
    lines.append("};")
    lines.append("")

    return "\n".join(lines)


# ========================================================================
# Source generation
# ========================================================================

def _method_comment(class_name, snake_name, description=""):
    """Generate a Panda3D-style function comment block."""
    lines = [
        "/" * 68,
        "//     Function: {}::{}".format(class_name, snake_name),
        "//       Access: Published, Static",
    ]
    if description:
        lines.append("//  Description: {}".format(description))
    lines.append("/" * 68)
    return "\n".join(lines)


def generate_source(iface_name, iface_data, iface_cfg, methods_info,
                    typedefs, enums):
    """Generate the .cpp file content for a single interface wrapper."""

    class_name = iface_cfg["class_name"]

    # Determine the accessor function (e.g. SteamAPI_SteamApps)
    # Prefer user > global > gameserver
    accessors = iface_data.get("accessors", [])
    accessor_fn = None
    for preferred_kind in ("user", "global", "gameserver"):
        for a in accessors:
            if a.get("kind") == preferred_kind:
                accessor_fn = "SteamAPI_{}".format(a["name"])
                break
        if accessor_fn:
            break

    # Header file name (lowercase of class_name)
    header_stem = _class_name_to_filename(class_name)

    lines = []
    lines.append(_GENERATED_BANNER)
    lines.append("")
    lines.append('#include "{}.h"'.format(header_stem))
    lines.append("")
    lines.append("// Guard everything below from interrogate's parser.")
    lines.append("#ifndef CPPPARSER")
    lines.append("")
    lines.append("#include <steam/steam_api.h>")
    lines.append("#include <steam/steam_api_flat.h>")

    # Extra includes
    for inc in iface_cfg.get("extra_includes", []):
        lines.append("#include {}".format(inc))

    lines.append("")

    # Interface accessor helper
    helper_name = "_get_{}".format(_camel_to_snake(iface_name.lstrip("I")))
    if accessor_fn:
        lines.append(
            "// Helper: returns the {} interface pointer, or nullptr if not initialized."
            .format(iface_name)
        )
        lines.append("static {} *{}() {{".format(iface_name, helper_name))
        lines.append("  return {}();".format(accessor_fn))
        lines.append("}")
        lines.append("")

    # init / shutdown
    if iface_cfg.get("include_api_lifecycle"):
        lines.append(_method_comment(class_name, "init",
                                     "Initializes the Steamworks API."))
        lines.append("bool {}::init() {{".format(class_name))
        lines.append("  return SteamAPI_Init();")
        lines.append("}")
        lines.append("")
        lines.append(_method_comment(class_name, "shutdown",
                                     "Shuts down the Steamworks API."))
        lines.append("void {}::shutdown() {{".format(class_name))
        lines.append("  SteamAPI_Shutdown();")
        lines.append("}")
        lines.append("")

    # Collect callresult types needed by async methods (for forward decls)
    needed_callresults = set()
    for method, kind, bpairs, ret_info, wrapper_params in methods_info:
        if kind == ASYNC:
            needed_callresults.add(method.get("callresult", ""))
    needed_callresults.discard("")

    # Forward declarations for async call-result registration functions
    if needed_callresults:
        lines.append("// Forward declarations for async call-result registration")
        for cr in sorted(needed_callresults):
            lines.append(
                "extern void _steam_async_call_{}"
                "(SteamAPICall_t, PyObject *);".format(cr))
        lines.append("")

    # Generated method bodies
    for method, kind, bpairs, ret_info, wrapper_params in methods_info:
        snake = steam_method_to_snake(method["methodname"], method["returntype"])
        steam_name = method["methodname"]
        ret_type_steam = method["returntype"].strip()

        if kind == ASYNC:
            _gen_async_method(lines, class_name, iface_name, helper_name,
                              method, snake, wrapper_params)
        elif kind == STRING_BUFFER:
            _gen_buffer_method(lines, class_name, iface_name, helper_name,
                               method, snake, bpairs, wrapper_params,
                               ret_type_steam, iface_cfg)
        elif ret_info[2] == "string":
            _gen_string_return_method(lines, class_name, iface_name,
                                     helper_name, method, snake,
                                     wrapper_params, ret_info)
        elif ret_info[2] == "steamid":
            _gen_steamid_return_method(lines, class_name, iface_name,
                                      helper_name, method, snake,
                                      wrapper_params, ret_info)
        elif ret_info[0] == "void":
            _gen_void_method(lines, class_name, iface_name, helper_name,
                             method, snake, wrapper_params)
        else:
            _gen_simple_method(lines, class_name, iface_name, helper_name,
                               method, snake, wrapper_params, ret_info)

    lines.append("#endif  // CPPPARSER")
    lines.append("")
    return "\n".join(lines)


# ========================================================================
# Individual method body generators
# ========================================================================

def _gen_simple_method(lines, cls, iface, helper, method, snake, params, ret):
    """bool/int/uint/etc return, no special handling."""
    cpp_ret, default, _ = ret
    steam_name = method["methodname"]
    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in params)
    call_args = ", ".join(_format_call_arg(pn, tr) for pn, _, tr in params)

    lines.append(_method_comment(cls, snake))
    lines.append("{} {}::{}({}) {{".format(cpp_ret, cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (!iface) return {};".format(default))
    lines.append("  return iface->{}({});".format(steam_name, call_args))
    lines.append("}")
    lines.append("")


def _gen_void_method(lines, cls, iface, helper, method, snake, params):
    """void return."""
    steam_name = method["methodname"]
    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in params)
    call_args = ", ".join(_format_call_arg(pn, tr) for pn, _, tr in params)

    lines.append(_method_comment(cls, snake))
    lines.append("void {}::{}({}) {{".format(cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (iface) iface->{}({});".format(steam_name, call_args))
    lines.append("}")
    lines.append("")


def _gen_string_return_method(lines, cls, iface, helper, method, snake,
                              params, ret):
    """const char * return -> std::string."""
    steam_name = method["methodname"]
    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in params)
    call_args = ", ".join(_format_call_arg(pn, tr) for pn, _, tr in params)

    lines.append(_method_comment(cls, snake))
    lines.append("std::string {}::{}({}) {{".format(cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (!iface) return std::string();")
    lines.append("  const char *result = iface->{}({});".format(steam_name, call_args))
    lines.append("  return result ? std::string(result) : std::string();")
    lines.append("}")
    lines.append("")


def _gen_steamid_return_method(lines, cls, iface, helper, method, snake,
                               params, ret):
    """CSteamID return -> unsigned long long via .ConvertToUint64()."""
    steam_name = method["methodname"]
    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in params)
    call_args = ", ".join(_format_call_arg(pn, tr) for pn, _, tr in params)

    lines.append(_method_comment(cls, snake))
    lines.append("unsigned long long {}::{}({}) {{".format(cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (!iface) return 0;")
    lines.append("  return iface->{}({}).ConvertToUint64();".format(steam_name, call_args))
    lines.append("}")
    lines.append("")


def _gen_buffer_method(lines, cls, iface, helper, method, snake, bpairs,
                       wrapper_params, ret_type_steam, iface_cfg):
    """char* + size buffer output -> std::string return.

    Handles methods like GetCurrentBetaName(char*, int) -> bool
    and GetAppInstallDir(AppId_t, char*, uint32) -> uint32.
    """
    steam_name = method["methodname"]
    buf_size = iface_cfg.get("buffer_sizes", {}).get(steam_name, cfg.DEFAULT_BUFFER_SIZE)

    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in wrapper_params)

    # Build the call arguments, inserting buf/sizeof(buf) for buffer pairs
    all_params = method.get("params", [])
    skip_indices = set()
    for ci, si in bpairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    call_parts = []
    wp_iter = iter(wrapper_params)
    for idx, p in enumerate(all_params):
        if idx in skip_indices:
            # Is this the char* of a pair?  Insert buf, sizeof(buf)
            for ci, si in bpairs:
                if idx == ci:
                    call_parts.append("buf")
                    call_parts.append("sizeof(buf)")
                    break
            # If it's the size param, we already added sizeof(buf) above
            continue
        wp = next(wp_iter)
        call_parts.append(_format_call_arg(wp[0], wp[2]))

    call_args = ", ".join(call_parts)

    lines.append(_method_comment(cls, snake))
    lines.append("std::string {}::{}({}) {{".format(cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (!iface) return std::string();")
    lines.append("  char buf[{}];".format(buf_size))

    # Call and check result
    if ret_type_steam == "bool":
        lines.append("  bool ok = iface->{}({});".format(steam_name, call_args))
        lines.append("  if (ok) return std::string(buf);")
    elif ret_type_steam in ("void",):
        lines.append("  iface->{}({});".format(steam_name, call_args))
        lines.append("  return std::string(buf);")
    else:
        # Numeric return (uint32, int) — treat as length
        lines.append("  {} len = iface->{}({});".format(ret_type_steam, steam_name, call_args))
        lines.append("  if (len > 0) return std::string(buf);")

    lines.append("  return std::string();")
    lines.append("}")
    lines.append("")


# ========================================================================
# Async method body generation
# ========================================================================

def _gen_async_method(lines, cls, iface, helper, method, snake, params):
    """SteamAPICall_t return -> async wrapper with Python callable callback."""
    steam_name = method["methodname"]
    callresult = method.get("callresult", "")

    param_decl = ", ".join(_format_header_param(pn, pt) for pn, pt, _ in params)
    if param_decl:
        param_decl += ", PyObject *callback"
    else:
        param_decl = "PyObject *callback"
    call_args = ", ".join(_format_call_arg(pn, tr) for pn, _, tr in params)

    lines.append(_method_comment(
        cls, snake,
        "Async. Invokes callback(dict) on completion."))
    lines.append(
        "unsigned long long {}::{}({}) {{".format(cls, snake, param_decl))
    lines.append("  {} *iface = {}();".format(iface, helper))
    lines.append("  if (!iface) return 0;")
    lines.append(
        "  SteamAPICall_t call = iface->{}({});".format(
            steam_name, call_args))
    lines.append("  if (call == k_uAPICallInvalid) return 0;")
    lines.append("  if (callback && callback != Py_None"
                 " && PyCallable_Check(callback)) {")
    lines.append(
        "    _steam_async_call_{}(call, callback);".format(callresult))
    lines.append("  }")
    lines.append("  return (unsigned long long)call;")
    lines.append("}")
    lines.append("")


# ========================================================================
# config_module.cpp generation
# ========================================================================

def generate_config_module_cpp(generated_headers):
    """Generate config_module.cpp with #includes for all generated headers."""
    lines = []
    lines.append(_GENERATED_BANNER)
    lines.append("")
    lines.append('#include "config_module.h"')
    lines.append("")
    for hdr in sorted(generated_headers):
        lines.append('#include "{}"'.format(hdr))
    lines.append("")
    lines.append('#include "dconfig.h"')
    lines.append("")
    lines.append("Configure(config_mymodule);")
    lines.append('NotifyCategoryDef(mymodule , "");')
    lines.append("")
    lines.append("ConfigureFn(config_mymodule) {")
    lines.append("  init_libmymodule();")
    lines.append("}")
    lines.append("")
    lines.append("void")
    lines.append("init_libmymodule() {")
    lines.append("  static bool initialized = false;")
    lines.append("  if (initialized) {")
    lines.append("    return;")
    lines.append("  }")
    lines.append("  initialized = true;")
    lines.append("")
    lines.append("  return;")
    lines.append("}")
    lines.append("")
    lines.append("")
    return "\n".join(lines)


# ========================================================================
# File name helpers
# ========================================================================

def _class_name_to_filename(class_name):
    """SteamApps -> steamApps   (camelCase file naming convention)."""
    if not class_name:
        return class_name
    return class_name[0].lower() + class_name[1:]


# ========================================================================
# Main entry point
# ========================================================================

def run_codegen(root_dir=None, check_only=False):
    """Run code generation.  Returns a list of generated file paths.

    Parameters
    ----------
    root_dir : str or None
        Repository root.  Defaults to the parent of the ``scripts/`` dir.
    check_only : bool
        If True, don't write files — just return whether they would change.
        Returns an empty list if everything is up to date, or a list of
        paths that would be modified.
    """
    if root_dir is None:
        root_dir = _ROOT_DIR

    json_path = os.path.join(root_dir, cfg.STEAM_API_JSON)
    output_dir = os.path.join(root_dir, cfg.OUTPUT_DIR)

    # Load the API definition
    with open(json_path, "r") as f:
        api_data = json.load(f)

    typedefs = _build_typedef_map(api_data)
    enums = _build_enum_set(api_data)

    # ------------------------------------------------------------------
    # Callback infrastructure setup
    # ------------------------------------------------------------------
    callback_struct_map = cbgen.build_callback_struct_map(api_data)
    async_struct_names = cbgen.collect_callresult_structs(api_data)
    broadcast_struct_names = cbgen.collect_broadcast_structs()
    all_needed_structs = async_struct_names | broadcast_struct_names

    generated_files = []
    generated_headers = []
    stale_files = []

    # ------------------------------------------------------------------
    # Generate callback manager files (steamCallbackManager.h / .cpp)
    # ------------------------------------------------------------------
    if all_needed_structs:
        # steamPython.h - PyObject compatibility header
        py_compat_content = cbgen.generate_python_compat_header(
            _GENERATED_BANNER)
        py_compat_path = os.path.join(output_dir, "steamPython.h")
        generated_headers.append("steamPython.h")

        cb_header_content = cbgen.generate_callback_manager_header(
            _GENERATED_BANNER)

        cb_source_content = cbgen.generate_callback_manager_source(
            async_struct_names,
            broadcast_struct_names, callback_struct_map,
            typedefs, enums, _GENERATED_BANNER)

        cb_header_path = os.path.join(output_dir, "steamCallbackManager.h")
        cb_source_path = os.path.join(output_dir, "steamCallbackManager.cpp")

        generated_headers.append("steamCallbackManager.h")

        for path, content in [(py_compat_path, py_compat_content),
                              (cb_header_path, cb_header_content),
                              (cb_source_path, cb_source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate per-interface wrapper files
    # ------------------------------------------------------------------
    for iface_data in api_data.get("interfaces", []):
        iface_name = iface_data["classname"]

        # Honor the skip list
        if iface_name in cfg.SKIP_INTERFACES:
            continue

        # Skip interfaces that have no accessor (callback interfaces, etc.)
        accessors = iface_data.get("accessors", [])
        if not accessors and iface_name != cfg.LIFECYCLE_INTERFACE:
            continue

        # Derive class name: strip leading "I" (ISteamApps -> SteamApps)
        class_name = iface_name
        if class_name.startswith("I"):
            class_name = class_name[1:]

        # Build iface_cfg from defaults + any per-interface overrides
        overrides = cfg.INTERFACE_OVERRIDES.get(iface_name, {})
        iface_cfg = {
            "class_name": overrides.get("class_name", class_name),
            "description": overrides.get(
                "description",
                "Wrapper around {}.".format(iface_name),
            ),
            "include_api_lifecycle": (iface_name == cfg.LIFECYCLE_INTERFACE),
            "skip_methods": overrides.get("skip_methods", []),
            "buffer_sizes": overrides.get("buffer_sizes", {}),
            "extra_includes": overrides.get("extra_includes", []),
        }

        class_name = iface_cfg["class_name"]
        file_stem = _class_name_to_filename(class_name)
        skip_set = set(iface_cfg.get("skip_methods", []))

        # Classify and filter methods
        methods_info = []  # (method, kind, bpairs, ret_info, wrapper_params)
        for method in iface_data.get("methods", []):
            if method["methodname"] in skip_set:
                continue
            kind, bpairs = classify_method(method, typedefs, enums)
            if kind == SKIP:
                continue

            ret_info = resolve_return_type(method["returntype"], typedefs, enums)
            wrapper_params = _make_wrapper_params(method, bpairs, typedefs, enums)
            methods_info.append((method, kind, bpairs, ret_info, wrapper_params))

        if not methods_info and not iface_cfg.get("include_api_lifecycle"):
            print("WARNING: no generatable methods for '{}', skipping."
                  .format(iface_name), file=sys.stderr)
            continue

        # Generate content
        header_content = generate_header(iface_name, iface_data, iface_cfg,
                                         methods_info)
        source_content = generate_source(iface_name, iface_data, iface_cfg,
                                         methods_info, typedefs, enums)

        header_path = os.path.join(output_dir, file_stem + ".h")
        source_path = os.path.join(output_dir, file_stem + ".cpp")

        generated_headers.append(file_stem + ".h")

        for path, content in [(header_path, header_content),
                              (source_path, source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate config_module.cpp
    # ------------------------------------------------------------------
    config_content = generate_config_module_cpp(generated_headers)
    config_path = os.path.join(output_dir, "config_module.cpp")

    if check_only:
        if not os.path.isfile(config_path):
            stale_files.append(config_path)
        else:
            with open(config_path, "r") as f:
                if f.read() != config_content:
                    stale_files.append(config_path)
        return stale_files
    else:
        _write_if_changed(config_path, config_content)
        generated_files.append(config_path)

    return generated_files


def _write_if_changed(path, content):
    """Write *content* to *path* only if the file doesn't already match."""
    if os.path.isfile(path):
        with open(path, "r") as f:
            if f.read() == content:
                return  # already up to date
    with open(path, "w", newline="\n") as f:
        f.write(content)
    print("  generated: {}".format(os.path.relpath(path, _ROOT_DIR)))


# ========================================================================
# CLI
# ========================================================================

def main():
    check_only = "--check" in sys.argv

    if check_only:
        stale = run_codegen(check_only=True)
        if stale:
            print("The following files are out of date:")
            for p in stale:
                print("  " + p)
            sys.exit(1)
        else:
            print("All generated files are up to date.")
            sys.exit(0)
    else:
        print("Generating Steamworks wrapper code ...")
        files = run_codegen()
        if files:
            print("Generated {} file(s).".format(len(files)))
        else:
            print("All files already up to date.")


if __name__ == "__main__":
    main()
