#!/usr/bin/env python3
"""
Code generator: reads steam_api.json and produces Panda3D-compatible
C++ wrapper classes (.h / .cpp) for the configured Steamworks interfaces.

Usage:
    ppython scripts/codegen.py            # generate into source/
    ppython scripts/codegen.py --check    # exit 1 if files are out of date

This script is also called automatically by setup.py before the CMake build.
"""

from __future__ import print_function

import json
import os
import re
import sys
import textwrap

import jinja2

# ---------------------------------------------------------------------------
# Make sure we can import the sibling config module regardless of CWD.
# ---------------------------------------------------------------------------
_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
_ROOT_DIR = os.path.normpath(os.path.join(_SCRIPT_DIR, ".."))

if _SCRIPT_DIR not in sys.path:
    sys.path.insert(0, _SCRIPT_DIR)

import codegen_config as cfg  # noqa: E402
import codegen_callbacks as cbgen  # noqa: E402

# ---------------------------------------------------------------------------
# Auto-generated file banner
# ---------------------------------------------------------------------------
_GENERATED_BANNER = (
    "///\n"
    "// Copyright (c) 2026, Digital Descent, LLC. All rights reserved.\n"
    "//\n"
    "// ======================================================================\n"
    "// AUTO-GENERATED by scripts/codegen.py - DO NOT EDIT BY HAND.\n"
    "// Re-generate with:  ppython scripts/codegen.py\n"
    "// ======================================================================"
)


# ========================================================================
# Name helpers
# ========================================================================

def _camel_to_snake(name):
    """Convert CamelCase / PascalCase to snake_case, keeping acronyms grouped.

    Examples:
        GetDLCCount   -> get_dlc_count
        BIsSubscribed -> b_is_subscribed  (caller strips B prefix separately)
        GetAppBuildId -> get_app_build_id
    """
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z\d])([A-Z])", r"\1_\2", s)
    return s.lower()


def _strip_hungarian(name):
    """Strip common Hungarian-notation prefixes from parameter names.

    Only strips when the remainder starts with an uppercase letter, so real
    words like ``count`` or ``name`` are left intact.
    """
    # Order matters — try longer prefixes first.
    prefixes = [
        "ppch", "ppsz",
        "pch", "psz", "pfn", "pfl", "pun", "pub", "pvec",
        "rgb", "rg",
        "pp", "pb", "pn", "pi", "pf",
        "fl", "un", "ul",
        "cb", "cch", "cub",
        "sz", "ch", "fn",
        "p", "n", "b", "e", "i", "c", "f",
    ]
    for pfx in prefixes:
        if name.startswith(pfx) and len(name) > len(pfx) and name[len(pfx)].isupper():
            return name[len(pfx):]
    return name


def steam_method_to_snake(method_name, return_type):
    """Convert a Steam method name to a Panda3D-style snake_case name.

    Strips the ``B`` prefix that Steamworks uses on boolean queries.
    """
    name = method_name
    if (return_type == "bool"
            and name.startswith("B")
            and len(name) > 1
            and name[1].isupper()):
        name = name[1:]
    return _camel_to_snake(name)


# C++ reserved keywords that cannot be used as parameter names
_CPP_KEYWORDS = frozenset({
    "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand",
    "bitor", "bool", "break", "case", "catch", "char", "char8_t",
    "char16_t", "char32_t", "class", "compl", "concept", "const",
    "consteval", "constexpr", "constinit", "const_cast", "continue",
    "co_await", "co_return", "co_yield", "decltype", "default", "delete",
    "do", "double", "dynamic_cast", "else", "enum", "explicit", "export",
    "extern", "false", "float", "for", "friend", "goto", "if", "inline",
    "int", "long", "mutable", "namespace", "new", "noexcept", "not",
    "not_eq", "nullptr", "operator", "or", "or_eq", "private", "protected",
    "public", "register", "reinterpret_cast", "requires", "return",
    "short", "signed", "sizeof", "static", "static_assert", "static_cast",
    "struct", "switch", "template", "this", "thread_local", "throw",
    "true", "try", "typedef", "typeid", "typename", "union", "unsigned",
    "using", "virtual", "void", "volatile", "wchar_t", "while", "xor",
    "xor_eq",
})


def steam_param_to_snake(param_name):
    """Convert a Steam parameter name to snake_case, stripping Hungarian."""
    name = _camel_to_snake(_strip_hungarian(param_name))
    if name in _CPP_KEYWORDS:
        name = name + "_val"
    return name


# ========================================================================
# Type resolution
# ========================================================================

def _build_typedef_map(api_data):
    """Build a dict of Steam typedef name -> underlying type."""
    result = {}
    for td in api_data.get("typedefs", []):
        result[td["typedef"]] = td["type"]
    return result


def _build_enum_set(api_data):
    """Build a set of all known enum type names."""
    result = set()
    for e in api_data.get("enums", []):
        result.add(e["enumname"])
    # Also grab nested enums inside callback_structs / structs
    for section in ("callback_structs", "structs"):
        for s in api_data.get(section, []):
            for e in s.get("enums", []):
                result.add(e.get("fqname", e["enumname"]))
                result.add(e["enumname"])
    return result


def resolve_return_type(steam_type, typedefs, enums):
    """Resolve a Steam return type to (cpp_type, default_value, handling) or None.

    Returns None if the method should be skipped.
    """
    st = steam_type.strip()

    # Direct lookup
    if st in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[st]

    # Typedef resolution (one level)
    if st in typedefs and typedefs[st] in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[typedefs[st]]

    # Enum -> int
    if st in enums:
        return ("int", "0", None)

    return None  # unknown -> skip


def resolve_param_type(steam_type, typedefs, enums):
    """Resolve a Steam parameter type to (cpp_type, call_transform) or None."""
    st = steam_type.strip()

    if st in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[st]

    if st in typedefs and typedefs[st] in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[typedefs[st]]

    if st in enums:
        return ("int", "enum_cast:{}".format(st))

    return None  # unknown -> skip


# ========================================================================
# Method classification
# ========================================================================

# Method kinds
SIMPLE = "simple"           # No special handling needed
STRING_BUFFER = "buffer"    # Has char*/size output pairs -> return std::string
SKIP = "skip"               # Cannot auto-generate
ASYNC = "async"             # SteamAPICall_t return -> CCallResult-based async wrapper


def classify_method(method, typedefs, enums):
    """Classify a method as SIMPLE, STRING_BUFFER, ASYNC, or SKIP.

    Returns (kind, buffer_pairs) where buffer_pairs is a list of
    (char_param_index, size_param_index) tuples for STRING_BUFFER methods.
    For ASYNC methods, buffer_pairs is always empty.
    """
    ret_type = method["returntype"].strip()
    params = method.get("params", [])

    # --- Async methods (SteamAPICall_t) ---
    if ret_type == "SteamAPICall_t":
        if not getattr(cfg, 'ENABLE_ASYNC_METHODS', False):
            return SKIP, []
        callresult = method.get("callresult", "")
        if not callresult:
            return SKIP, []
        skip_cb = getattr(cfg, 'SKIP_CALLBACK_STRUCTS', set())
        if callresult in skip_cb:
            return SKIP, []
        # Verify all params are resolvable and no output pointers
        for p in params:
            pt = p["paramtype"].strip()
            if pt.endswith("*") and not pt.startswith("const "):
                return SKIP, []
            if resolve_param_type(pt, typedefs, enums) is None:
                return SKIP, []
        return ASYNC, []

    # --- Sync methods ---
    if resolve_return_type(ret_type, typedefs, enums) is None:
        return SKIP, []

    # Scan for pointer params
    buffer_pairs = []       # (char_idx, size_idx)
    other_pointers = []     # indices of non-buffer pointer params

    i = 0
    while i < len(params):
        pt = params[i]["paramtype"].strip()

        if pt == "char *":
            # Check if next param is a buffer size
            if (i + 1 < len(params)
                    and params[i + 1]["paramtype"].strip() in ("int", "uint32", "int32")):
                buffer_pairs.append((i, i + 1))
                i += 2
                continue
            else:
                other_pointers.append(i)
        elif pt.endswith("*") and not pt.startswith("const "):
            other_pointers.append(i)

        i += 1

    if other_pointers:
        return SKIP, []

    # Check that all non-buffer params can be resolved
    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    for idx, p in enumerate(params):
        if idx in skip_indices:
            continue
        if resolve_param_type(p["paramtype"], typedefs, enums) is None:
            return SKIP, []

    if buffer_pairs:
        return STRING_BUFFER, buffer_pairs
    return SIMPLE, []


# ========================================================================
# Code generation helpers
# ========================================================================

def _needs_string_include(methods_info):
    """Check if any generated method uses std::string."""
    for _method, _kind, _bpairs, ret_info, _wrapper_params in methods_info:
        if ret_info and ret_info[0] == "std::string":
            return True
        for _pname, ptype, _ptransform in _wrapper_params:
            if ptype == "const std::string &":
                return True
    return False


def _has_async_methods(methods_info):
    """Check if any method is ASYNC (needs PyObject / steamPython.h)."""
    return any(kind == ASYNC for _, kind, _, _, _ in methods_info)


def _make_wrapper_params(method, buffer_pairs, typedefs, enums):
    """Build the list of (param_name, cpp_type, call_transform) for wrapper.

    Buffer-pair params are excluded.
    """
    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    result = []
    for idx, p in enumerate(method.get("params", [])):
        if idx in skip_indices:
            continue
        cpp_type, transform = resolve_param_type(p["paramtype"], typedefs, enums)
        pname = steam_param_to_snake(p["paramname"])
        result.append((pname, cpp_type, transform))
    return result


def _format_header_param(pname, ptype):
    """Format a single parameter for a header declaration."""
    return "{} {}".format(ptype, pname)


def _format_call_arg(pname, transform):
    """Format a single argument for calling into the Steam API."""
    if transform == "c_str":
        return "{}.c_str()".format(pname)
    if transform == "steamid_from":
        return "CSteamID({})".format(pname)
    if transform and transform.startswith("enum_cast:"):
        enum_type = transform[len("enum_cast:"):]
        return "static_cast<{}>({})".format(enum_type, pname)
    return pname


# ========================================================================
# Jinja2 template environment
# ========================================================================

_TEMPLATES_DIR = os.path.join(_SCRIPT_DIR, "templates")

_jinja_env = None


def _get_jinja_env():
    """Return (and cache) a Jinja2 Environment pointing at scripts/templates/."""
    global _jinja_env
    if _jinja_env is None:
        _jinja_env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(_TEMPLATES_DIR),
            trim_blocks=True,
            lstrip_blocks=True,
            keep_trailing_newline=True,
        )
    return _jinja_env


# ========================================================================
# Method context helpers (prepare data for templates)
# ========================================================================

def _compute_buffer_call_args(method, bpairs, wrapper_params):
    """Build the call-argument string for a STRING_BUFFER method.

    Inserts ``buf, sizeof(buf)`` in place of the char*/size parameter pairs.
    """
    all_params = method.get("params", [])
    skip_indices = set()
    for ci, si in bpairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    call_parts = []
    wp_iter = iter(wrapper_params)
    for idx, _p in enumerate(all_params):
        if idx in skip_indices:
            for ci, _si in bpairs:
                if idx == ci:
                    call_parts.append("buf")
                    call_parts.append("sizeof(buf)")
                    break
            continue
        wp = next(wp_iter)
        call_parts.append(_format_call_arg(wp[0], wp[2]))

    return ", ".join(call_parts)


def _determine_method_kind(kind, ret_info):
    """Map (classify kind, ret_info) to a template-friendly kind string."""
    if kind == ASYNC:
        return "async"
    if kind == STRING_BUFFER:
        return "buffer"
    if ret_info[2] == "string":
        return "string_return"
    if ret_info[2] == "steamid":
        return "steamid_return"
    if ret_info[0] == "void":
        return "void"
    return "simple"


def _prepare_header_method(method, kind, bpairs, ret_info, wrapper_params):
    """Build a context dict for a single method in the header template."""
    snake = steam_method_to_snake(method["methodname"], method["returntype"])

    if kind == ASYNC:
        ret_cpp = "unsigned long long"
    elif kind == STRING_BUFFER:
        ret_cpp = "std::string"
    else:
        ret_cpp = ret_info[0]

    param_str = ", ".join(
        _format_header_param(pn, pt) for pn, pt, _ in wrapper_params
    )
    if kind == ASYNC:
        if param_str:
            param_str += ", PyObject *callback"
        else:
            param_str = "PyObject *callback"

    return {
        "kind": "async" if kind == ASYNC else "other",
        "snake_name": snake,
        "return_type": ret_cpp,
        "params_str": param_str,
    }


def _prepare_source_method(method, kind, bpairs, ret_info, wrapper_params,
                           iface_cfg):
    """Build a context dict for a single method in the source template."""
    snake = steam_method_to_snake(method["methodname"], method["returntype"])
    steam_name = method["methodname"]

    param_decl = ", ".join(
        _format_header_param(pn, pt) for pn, pt, _ in wrapper_params
    )
    call_args = ", ".join(
        _format_call_arg(pn, tr) for pn, _, tr in wrapper_params
    )

    tmpl_kind = _determine_method_kind(kind, ret_info)

    ctx = {
        "kind": tmpl_kind,
        "snake_name": snake,
        "steam_name": steam_name,
        "param_decl": param_decl,
        "call_args": call_args,
    }

    if tmpl_kind == "simple":
        ctx["return_type"] = ret_info[0]
        ctx["default_value"] = ret_info[1]
    elif tmpl_kind == "buffer":
        buf_size = iface_cfg.get("buffer_sizes", {}).get(
            steam_name, cfg.DEFAULT_BUFFER_SIZE)
        ctx["buf_size"] = buf_size
        ctx["ret_type_steam"] = method["returntype"].strip()
        ctx["buffer_call_args"] = _compute_buffer_call_args(
            method, bpairs, wrapper_params)
    elif tmpl_kind == "async":
        ctx["callresult"] = method.get("callresult", "")
        if param_decl:
            ctx["param_decl"] = param_decl + ", PyObject *callback"
        else:
            ctx["param_decl"] = "PyObject *callback"

    return ctx


# ========================================================================
# Header generation
# ========================================================================

def generate_header(iface_name, iface_data, iface_cfg, methods_info):
    """Generate the .h file content for a single interface wrapper."""
    env = _get_jinja_env()
    tmpl = env.get_template("interface_header.h.j2")

    class_name = iface_cfg["class_name"]
    description = iface_cfg.get(
        "description", "Wrapper around {}.".format(iface_name))

    methods = [
        _prepare_header_method(m, k, bp, ri, wp)
        for m, k, bp, ri, wp in methods_info
    ]

    return tmpl.render(
        banner=_GENERATED_BANNER,
        class_name=class_name,
        description_lines=description.split("\n"),
        needs_string=_needs_string_include(methods_info),
        has_async=_has_async_methods(methods_info),
        include_api_lifecycle=iface_cfg.get("include_api_lifecycle", False),
        methods=methods,
        extra_methods=iface_cfg.get("extra_methods", []),
    )


# ========================================================================
# Source generation
# ========================================================================

def generate_source(iface_name, iface_data, iface_cfg, methods_info,
                    typedefs, enums):
    """Generate the .cpp file content for a single interface wrapper."""
    env = _get_jinja_env()
    tmpl = env.get_template("interface_source.cpp.j2")

    class_name = iface_cfg["class_name"]

    # Determine the accessor function (e.g. SteamAPI_SteamApps)
    accessors = iface_data.get("accessors", [])
    accessor_fn = None
    for preferred_kind in ("user", "global", "gameserver"):
        for a in accessors:
            if a.get("kind") == preferred_kind:
                accessor_fn = "SteamAPI_{}".format(a["name"])
                break
        if accessor_fn:
            break

    helper_name = "_get_{}".format(_camel_to_snake(iface_name.lstrip("I")))
    header_stem = _class_name_to_filename(class_name)

    # Collect callresult types needed by async methods
    needed_callresults = sorted({
        method.get("callresult", "")
        for method, kind, *_ in methods_info
        if kind == ASYNC
    } - {""})

    # Build per-method template contexts
    methods = [
        _prepare_source_method(m, k, bp, ri, wp, iface_cfg)
        for m, k, bp, ri, wp in methods_info
    ]

    return tmpl.render(
        banner=_GENERATED_BANNER,
        header_stem=header_stem,
        class_name=class_name,
        iface_name=iface_name,
        accessor_fn=accessor_fn,
        helper_name=helper_name,
        extra_includes=iface_cfg.get("extra_includes", []),
        include_api_lifecycle=iface_cfg.get("include_api_lifecycle", False),
        needed_callresults=needed_callresults,
        methods=methods,
        extra_methods=iface_cfg.get("extra_methods", []),
    )


# ========================================================================
# Enum wrapper class generation
# ========================================================================

def _enum_class_name(enum_name):
    """Derive a wrapper class name from a Steam enum name.

    EFriendFlags -> SteamFriendFlags
    ESteamIPType -> SteamIPType
    AudioPlayback_Status -> SteamAudioPlaybackStatus
    """
    name = enum_name
    if name.startswith("E") and len(name) > 1 and name[1].isupper():
        name = name[1:]
    name = name.replace("_", "")
    prefix = getattr(cfg, "ENUM_CLASS_PREFIX", "Steam")
    if name.startswith(prefix):
        return name
    return "{}{}".format(prefix, name)


def generate_enums_header(api_data):
    """Generate steamEnums_bindings.h containing one PUBLISHED class per enum."""
    env = _get_jinja_env()
    tmpl = env.get_template("enums_header.h.j2")

    skip = getattr(cfg, "SKIP_ENUMS", set())
    enums = []
    for enum_data in api_data.get("enums", []):
        enum_name = enum_data["enumname"]
        if enum_name in skip:
            continue
        values = enum_data.get("values", [])
        if not values:
            continue
        enums.append({
            "class_name": _enum_class_name(enum_name),
            "enum_name": enum_name,
            "constants": values,
        })

    return tmpl.render(banner=_GENERATED_BANNER, enums=enums)


def generate_enums_source():
    """Generate steamEnums.cpp — just includes the header."""
    env = _get_jinja_env()
    tmpl = env.get_template("enums_source.cpp.j2")
    return tmpl.render(banner=_GENERATED_BANNER)


# ========================================================================
# Constants generation
# ========================================================================

# Bit-width masks for unsigned types so Python ~ operator yields unsigned vals.
_UNSIGNED_MASKS = {
    "unsigned char":      0xFF,
    "unsigned short":     0xFFFF,
    "unsigned int":       0xFFFFFFFF,
    "unsigned long long": 0xFFFFFFFFFFFFFFFF,
}


def _evaluate_const_expr(raw_value, resolved):
    """Best-effort evaluation of a C++ constant expression in Python.

    *resolved* is a dict {const_name: python_value} of previously evaluated
    constants so forward references can be resolved.

    Returns the evaluated Python numeric value, or *None* if evaluation fails.
    """
    expr = raw_value.strip()

    # Strip C-style casts:  ( TypeName )  →  removed
    expr = re.sub(r"\(\s*[A-Za-z_]\w*\s*\)", "", expr)

    # Strip integer literal suffixes: 0xFFull, 16U, 100LL, etc.
    expr = re.sub(r"(0[xX][0-9a-fA-F]+)[uUlL]+\b", r"\1", expr)
    expr = re.sub(r"(\d+)[uUlL]+\b", r"\1", expr)

    # Float literal suffix: 600.f → 600.0, 3.14f → 3.14
    expr = re.sub(r"(\d+)\.f\b", r"\1.0", expr)
    expr = re.sub(r"(\d+\.\d+)f\b", r"\1", expr)

    # Replace character literals with ord():  'd' → 100
    expr = re.sub(r"'(.)'", lambda m: str(ord(m.group(1))), expr)

    # Collapse whitespace around minus sign: "- 1" → "-1"
    expr = re.sub(r"-\s+(\d)", r"-\1", expr)

    # Substitute references to previously resolved constants.  Use word-
    # boundary matching and process longest names first to avoid partial
    # matches (e.g. k_nFoo before k_nFooBar would be wrong).
    for name in sorted(resolved, key=len, reverse=True):
        expr = re.sub(r"\b" + re.escape(name) + r"\b",
                       str(resolved[name]), expr)

    try:
        return eval(expr)    # noqa: S307 – controlled input
    except Exception:
        return None


def _format_const_value(value, cpp_type, is_float):
    """Format an evaluated Python number as a C++ literal string."""
    if is_float:
        return "{:.1f}f".format(float(value))

    int_val = int(value)
    mask = _UNSIGNED_MASKS.get(cpp_type)
    if mask is not None:
        int_val = int_val & mask

    # Use hex for large unsigned values (> 0xFFFF) for readability.
    if mask is not None and int_val > 0xFFFF:
        width = {0xFF: 2, 0xFFFF: 4, 0xFFFFFFFF: 8,
                 0xFFFFFFFFFFFFFFFF: 16}[mask]
        return "0x{val:0{w}X}".format(val=int_val, w=width)

    return str(int_val)


def generate_constants_header(api_data):
    """Generate steamConstants_bindings.h with all Steamworks constants."""
    env = _get_jinja_env()
    tmpl = env.get_template("constants_header.h.j2")

    skip = getattr(cfg, "SKIP_CONSTANTS", set())
    type_map = getattr(cfg, "CONST_TYPES", {})

    resolved = {}   # name → evaluated Python numeric value
    constants = []

    for cdata in api_data.get("consts", []):
        name = cdata["constname"]
        ctype = cdata["consttype"]
        raw_val = cdata["constval"]

        if name in skip:
            continue

        cpp_type = type_map.get(ctype)
        if cpp_type is None:
            print("WARNING: unknown const type '{}' for '{}', skipping."
                  .format(ctype, name), file=sys.stderr)
            continue

        is_float = cpp_type in ("float", "double")

        evaluated = _evaluate_const_expr(raw_val, resolved)
        if evaluated is None:
            print("WARNING: could not evaluate const '{}' = '{}', skipping."
                  .format(name, raw_val), file=sys.stderr)
            continue

        # Store for forward-reference resolution
        resolved[name] = evaluated

        formatted = _format_const_value(evaluated, cpp_type, is_float)

        constants.append({
            "name": name,
            "cpp_type": cpp_type,
            "value": formatted,
            "is_float": is_float,
            "comment": None,
        })

    return tmpl.render(banner=_GENERATED_BANNER, constants=constants)


def generate_constants_source():
    """Generate steamConstants_bindings.cpp — just includes the header."""
    env = _get_jinja_env()
    tmpl = env.get_template("constants_source.cpp.j2")
    return tmpl.render(banner=_GENERATED_BANNER)


# ========================================================================
# config_module.cpp generation
# ========================================================================

def generate_config_module_cpp(generated_headers):
    """Generate config_module.cpp with #includes for all generated headers."""
    env = _get_jinja_env()
    tmpl = env.get_template("config_module.cpp.j2")
    return tmpl.render(
        banner=_GENERATED_BANNER,
        generated_headers=sorted(generated_headers),
    )


# ========================================================================
# File name helpers
# ========================================================================

def _class_name_to_filename(class_name):
    """SteamApps -> steamApps_bindings   (camelCase + _bindings suffix)."""
    if not class_name:
        return class_name
    return class_name[0].lower() + class_name[1:] + "_bindings"


# ========================================================================
# Main entry point
# ========================================================================

def run_codegen(root_dir=None, check_only=False):
    """Run code generation.  Returns a list of generated file paths.

    Parameters
    ----------
    root_dir : str or None
        Repository root.  Defaults to the parent of the ``scripts/`` dir.
    check_only : bool
        If True, don't write files — just return whether they would change.
        Returns an empty list if everything is up to date, or a list of
        paths that would be modified.
    """
    if root_dir is None:
        root_dir = _ROOT_DIR

    json_path = os.path.join(root_dir, cfg.STEAM_API_JSON)
    output_dir = os.path.join(root_dir, cfg.OUTPUT_DIR)

    # Load the API definition
    with open(json_path, "r") as f:
        api_data = json.load(f)

    typedefs = _build_typedef_map(api_data)
    enums = _build_enum_set(api_data)

    # ------------------------------------------------------------------
    # Callback infrastructure setup
    # ------------------------------------------------------------------
    callback_struct_map = cbgen.build_callback_struct_map(api_data)
    async_struct_names = cbgen.collect_callresult_structs(api_data)
    broadcast_struct_names = cbgen.collect_broadcast_structs()
    all_needed_structs = async_struct_names | broadcast_struct_names

    generated_files = []
    generated_headers = []
    stale_files = []

    # ------------------------------------------------------------------
    # Generate callback manager files (steamCallbackManager.h / .cpp)
    # ------------------------------------------------------------------
    if all_needed_structs:
        # steamPython.h - PyObject compatibility header
        py_compat_content = cbgen.generate_python_compat_header(
            _GENERATED_BANNER)
        py_compat_path = os.path.join(output_dir, "steamPython_bindings.h")
        generated_headers.append("steamPython_bindings.h")

        cb_header_content = cbgen.generate_callback_manager_header(
            _GENERATED_BANNER)

        cb_source_content = cbgen.generate_callback_manager_source(
            async_struct_names,
            broadcast_struct_names, callback_struct_map,
            typedefs, enums, _GENERATED_BANNER)

        cb_header_path = os.path.join(output_dir, "steamCallbackManager_bindings.h")
        cb_source_path = os.path.join(output_dir, "steamCallbackManager_bindings.cpp")

        generated_headers.append("steamCallbackManager_bindings.h")

        for path, content in [(py_compat_path, py_compat_content),
                              (cb_header_path, cb_header_content),
                              (cb_source_path, cb_source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate enum wrapper classes (steamEnums_bindings.h / .cpp)
    # ------------------------------------------------------------------
    if getattr(cfg, "ENABLE_ENUMS", False):
        enum_header_content = generate_enums_header(api_data)
        enum_source_content = generate_enums_source()
        enum_header_path = os.path.join(output_dir, "steamEnums_bindings.h")
        enum_source_path = os.path.join(output_dir, "steamEnums_bindings.cpp")
        generated_headers.append("steamEnums_bindings.h")

        for path, content in [(enum_header_path, enum_header_content),
                              (enum_source_path, enum_source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate constants wrapper class (steamConstants_bindings.h / .cpp)
    # ------------------------------------------------------------------
    if getattr(cfg, "ENABLE_CONSTANTS", False):
        const_header_content = generate_constants_header(api_data)
        const_source_content = generate_constants_source()
        const_header_path = os.path.join(output_dir,
                                         "steamConstants_bindings.h")
        const_source_path = os.path.join(output_dir,
                                         "steamConstants_bindings.cpp")
        generated_headers.append("steamConstants_bindings.h")

        for path, content in [(const_header_path, const_header_content),
                              (const_source_path, const_source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate per-interface wrapper files
    # ------------------------------------------------------------------
    for iface_data in api_data.get("interfaces", []):
        iface_name = iface_data["classname"]

        # Honor the skip list
        if iface_name in cfg.SKIP_INTERFACES:
            continue

        # Skip interfaces that have no accessor (callback interfaces, etc.)
        accessors = iface_data.get("accessors", [])
        if not accessors and iface_name != cfg.LIFECYCLE_INTERFACE:
            continue

        # Derive class name: strip leading "I" (ISteamApps -> SteamApps)
        class_name = iface_name
        if class_name.startswith("I"):
            class_name = class_name[1:]

        # Build iface_cfg from defaults + any per-interface overrides
        overrides = cfg.INTERFACE_OVERRIDES.get(iface_name, {})
        iface_cfg = {
            "class_name": overrides.get("class_name", class_name),
            "description": overrides.get(
                "description",
                "Wrapper around {}.".format(iface_name),
            ),
            "include_api_lifecycle": (iface_name == cfg.LIFECYCLE_INTERFACE),
            "skip_methods": overrides.get("skip_methods", []),
            "buffer_sizes": overrides.get("buffer_sizes", {}),
            "extra_includes": overrides.get("extra_includes", []),
            "extra_methods": overrides.get("extra_methods", []),
        }

        class_name = iface_cfg["class_name"]
        file_stem = _class_name_to_filename(class_name)
        skip_set = set(iface_cfg.get("skip_methods", []))

        # Classify and filter methods
        methods_info = []  # (method, kind, bpairs, ret_info, wrapper_params)
        for method in iface_data.get("methods", []):
            if method["methodname"] in skip_set:
                continue
            kind, bpairs = classify_method(method, typedefs, enums)
            if kind == SKIP:
                continue

            ret_info = resolve_return_type(method["returntype"], typedefs, enums)
            wrapper_params = _make_wrapper_params(method, bpairs, typedefs, enums)
            methods_info.append((method, kind, bpairs, ret_info, wrapper_params))

        if not methods_info and not iface_cfg.get("include_api_lifecycle"):
            print("WARNING: no generatable methods for '{}', skipping."
                  .format(iface_name), file=sys.stderr)
            continue

        # Generate content
        header_content = generate_header(iface_name, iface_data, iface_cfg,
                                         methods_info)
        source_content = generate_source(iface_name, iface_data, iface_cfg,
                                         methods_info, typedefs, enums)

        header_path = os.path.join(output_dir, file_stem + ".h")
        source_path = os.path.join(output_dir, file_stem + ".cpp")

        generated_headers.append(file_stem + ".h")

        for path, content in [(header_path, header_content),
                              (source_path, source_content)]:
            if check_only:
                if not os.path.isfile(path):
                    stale_files.append(path)
                else:
                    with open(path, "r") as f:
                        if f.read() != content:
                            stale_files.append(path)
            else:
                _write_if_changed(path, content)
                generated_files.append(path)

    # ------------------------------------------------------------------
    # Generate config_module.cpp
    # ------------------------------------------------------------------
    config_content = generate_config_module_cpp(generated_headers)
    config_path = os.path.join(output_dir, "config_module.cpp")

    if check_only:
        if not os.path.isfile(config_path):
            stale_files.append(config_path)
        else:
            with open(config_path, "r") as f:
                if f.read() != config_content:
                    stale_files.append(config_path)
        return stale_files
    else:
        _write_if_changed(config_path, config_content)
        generated_files.append(config_path)

    return generated_files


def _write_if_changed(path, content):
    """Write *content* to *path* only if the file doesn't already match."""
    if os.path.isfile(path):
        with open(path, "r") as f:
            if f.read() == content:
                return  # already up to date
    with open(path, "w", newline="\n") as f:
        f.write(content)
    print("  generated: {}".format(os.path.relpath(path, _ROOT_DIR)))


# ========================================================================
# CLI
# ========================================================================

def main():
    check_only = "--check" in sys.argv

    if check_only:
        stale = run_codegen(check_only=True)
        if stale:
            print("The following files are out of date:")
            for p in stale:
                print("  " + p)
            sys.exit(1)
        else:
            print("All generated files are up to date.")
            sys.exit(0)
    else:
        print("Generating Steamworks wrapper code ...")
        files = run_codegen()
        if files:
            print("Generated {} file(s).".format(len(files)))
        else:
            print("All files already up to date.")


if __name__ == "__main__":
    main()
