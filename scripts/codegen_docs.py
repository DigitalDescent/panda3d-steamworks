#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Documentation generator: reads steam_api.json and codegen_config.py to produce
Jekyll-compatible Markdown API reference pages under docs/api/.

This ensures documentation stays in sync with the generated C++ wrappers.

Usage:
    python scripts/codegen_docs.py            # generate into docs/api/
    python scripts/codegen_docs.py --check    # exit 1 if files are out of date

This can also be called from setup.py or CI.
"""

from __future__ import print_function

import json
import os
import re
import sys
import textwrap

# ---------------------------------------------------------------------------
# Make sure we can import the sibling config module regardless of CWD.
# ---------------------------------------------------------------------------
_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
_ROOT_DIR = os.path.normpath(os.path.join(_SCRIPT_DIR, ".."))

if _SCRIPT_DIR not in sys.path:
    sys.path.insert(0, _SCRIPT_DIR)

import codegen_config as cfg  # noqa: E402

# ---------------------------------------------------------------------------
# Banner appended as an HTML comment in generated Markdown files
# ---------------------------------------------------------------------------
_GENERATED_COMMENT = (
    "<!-- AUTO-GENERATED by scripts/codegen_docs.py - DO NOT EDIT BY HAND. -->\n"
    "<!-- Re-generate with:  python scripts/codegen_docs.py -->"
)

# ---------------------------------------------------------------------------
# Output directory for generated documentation (relative to repo root)
# ---------------------------------------------------------------------------
DOCS_API_DIR = os.path.join("docs", "api")

# ---------------------------------------------------------------------------
# Example files that map to interfaces.
# Keys are interface names (without "I" prefix), values are lists of
# (example_filename, description) tuples.
# ---------------------------------------------------------------------------
INTERFACE_EXAMPLES = {
    "SteamApps": [
        ("basic_app_info.py", "Basic app info queries"),
        ("ownership_check.py", "Ownership and subscription checks"),
        ("dlc_management.py", "DLC management"),
        ("app_installed_check.py", "App installed check"),
    ],
    "SteamFriends": [
        ("friends_list.py", "Friends list and info"),
        ("rich_presence.py", "Rich presence"),
        ("overlay_and_utils.py", "Overlay and utility features"),
    ],
    "SteamMatchmaking": [
        ("matchmaking.py", "Lobby creation and matchmaking"),
    ],
    "SteamRemoteStorage": [
        ("cloud_storage.py", "Cloud save read/write"),
    ],
    "SteamUserStats": [
        ("achievements.py", "Achievements"),
    ],
    "SteamUGC": [
        ("workshop.py", "Workshop item management"),
    ],
    "SteamUser": [
        ("user_info.py", "User identity and auth info"),
    ],
    "SteamUtils": [
        ("overlay_and_utils.py", "Overlay and utility features"),
    ],
    "SteamInput": [
        ("input_system.py", "Input / controller system"),
    ],
    "SteamInventory": [
        ("inventory.py", "Inventory management"),
    ],
    "SteamScreenshots": [
        ("screenshots.py", "Screenshot capture"),
    ],
    "SteamMusic": [
        ("music_player.py", "Music player control"),
    ],
    "SteamHTMLSurface": [
        ("html_surface.py", "Embedded HTML browser"),
    ],
    "SteamTimeline": [
        ("timeline.py", "Game recording timeline"),
    ],
    "SteamRemotePlay": [
        ("remote_play.py", "Remote Play Together"),
    ],
    "SteamParties": [
        ("parties.py", "Parties and beacons"),
    ],
    "SteamParentalSettings": [
        ("parental_settings.py", "Parental settings"),
    ],
    "SteamNetworkingSockets": [
        ("networking.py", "Networking sockets"),
    ],
    "SteamGameServer": [
        ("game_server.py", "Dedicated game server"),
    ],
    "SteamVideo": [
        ("video.py", "Steam Video"),
    ],
}

# ---------------------------------------------------------------------------
# Interface categories for the API index page
# ---------------------------------------------------------------------------
INTERFACE_CATEGORIES = [
    ("Core", [
        "SteamApps",
        "SteamUser",
        "SteamUtils",
    ]),
    ("Social", [
        "SteamFriends",
        "SteamParties",
    ]),
    ("Stats & Achievements", [
        "SteamUserStats",
    ]),
    ("Multiplayer", [
        "SteamMatchmaking",
        "SteamMatchmakingServers",
        "SteamNetworkingSockets",
        "SteamNetworkingMessages",
        "SteamNetworkingUtils",
        "SteamNetworking",
    ]),
    ("Storage & Cloud", [
        "SteamRemoteStorage",
    ]),
    ("Workshop / UGC", [
        "SteamUGC",
    ]),
    ("Input", [
        "SteamInput",
        "SteamController",
    ]),
    ("Game Servers", [
        "SteamGameServer",
        "SteamGameServerStats",
    ]),
    ("Inventory & Commerce", [
        "SteamInventory",
    ]),
    ("Media", [
        "SteamHTMLSurface",
        "SteamScreenshots",
        "SteamMusic",
        "SteamVideo",
        "SteamTimeline",
    ]),
    ("Remote Play & Streaming", [
        "SteamRemotePlay",
    ]),
    ("Parental", [
        "SteamParentalSettings",
    ]),
    ("HTTP", [
        "SteamHTTP",
    ]),
]


# ========================================================================
# Name helpers (mirrors codegen.py logic exactly)
# ========================================================================

def _camel_to_snake(name):
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", name)
    s = re.sub(r"([a-z\d])([A-Z])", r"\1_\2", s)
    return s.lower()


def _strip_hungarian(name):
    prefixes = [
        "ppch", "ppsz",
        "pch", "psz", "pfn", "pfl", "pun", "pub", "pvec",
        "rgb", "rg",
        "pp", "pb", "pn", "pi", "pf",
        "fl", "un", "ul",
        "cb", "cch", "cub",
        "sz", "ch", "fn",
        "p", "n", "b", "e", "i", "c", "f",
    ]
    for pfx in prefixes:
        if name.startswith(pfx) and len(name) > len(pfx) and name[len(pfx)].isupper():
            return name[len(pfx):]
    return name


def steam_method_to_snake(method_name, return_type):
    name = method_name
    if (return_type == "bool"
            and name.startswith("B")
            and len(name) > 1
            and name[1].isupper()):
        name = name[1:]
    return _camel_to_snake(name)


def steam_param_to_snake(param_name):
    _CPP_KEYWORDS = frozenset({
        "alignas", "alignof", "and", "and_eq", "asm", "auto", "bitand",
        "bitor", "bool", "break", "case", "catch", "char", "class",
        "const", "continue", "default", "delete", "do", "double", "else",
        "enum", "explicit", "export", "extern", "false", "float", "for",
        "friend", "goto", "if", "inline", "int", "long", "mutable",
        "namespace", "new", "noexcept", "not", "nullptr", "operator",
        "or", "private", "protected", "public", "register", "return",
        "short", "signed", "sizeof", "static", "struct", "switch",
        "template", "this", "throw", "true", "try", "typedef", "typeid",
        "typename", "union", "unsigned", "using", "virtual", "void",
        "volatile", "while",
    })
    name = _camel_to_snake(_strip_hungarian(param_name))
    if name in _CPP_KEYWORDS:
        name = name + "_val"
    return name


# ========================================================================
# Type resolution (mirrors codegen.py)
# ========================================================================

def _build_typedef_map(api_data):
    result = {}
    for td in api_data.get("typedefs", []):
        result[td["typedef"]] = td["type"]
    return result


def _build_enum_set(api_data):
    result = set()
    for e in api_data.get("enums", []):
        result.add(e["enumname"])
    for section in ("callback_structs", "structs"):
        for s in api_data.get(section, []):
            for e in s.get("enums", []):
                result.add(e.get("fqname", e["enumname"]))
                result.add(e["enumname"])
    return result


def resolve_return_type(steam_type, typedefs, enums):
    st = steam_type.strip()
    if st in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[st]
    if st in typedefs and typedefs[st] in cfg.RETURN_TYPES:
        return cfg.RETURN_TYPES[typedefs[st]]
    if st in enums:
        return ("int", "0", None)
    return None


def resolve_param_type(steam_type, typedefs, enums):
    st = steam_type.strip()
    if st in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[st]
    if st in typedefs and typedefs[st] in cfg.PARAM_TYPES:
        return cfg.PARAM_TYPES[typedefs[st]]
    if st in enums:
        return ("int", "enum_cast:{}".format(st))
    return None


# ========================================================================
# Method classification (mirrors codegen.py)
# ========================================================================

SIMPLE = "simple"
STRING_BUFFER = "buffer"
SKIP = "skip"
ASYNC = "async"


def classify_method(method, typedefs, enums):
    ret_type = method["returntype"].strip()
    params = method.get("params", [])

    if ret_type == "SteamAPICall_t":
        if not getattr(cfg, 'ENABLE_ASYNC_METHODS', False):
            return SKIP, []
        callresult = method.get("callresult", "")
        if not callresult:
            return SKIP, []
        skip_cb = getattr(cfg, 'SKIP_CALLBACK_STRUCTS', set())
        if callresult in skip_cb:
            return SKIP, []
        for p in params:
            pt = p["paramtype"].strip()
            if pt.endswith("*") and not pt.startswith("const "):
                return SKIP, []
            if resolve_param_type(pt, typedefs, enums) is None:
                return SKIP, []
        return ASYNC, []

    if resolve_return_type(ret_type, typedefs, enums) is None:
        return SKIP, []

    buffer_pairs = []
    other_pointers = []

    i = 0
    while i < len(params):
        pt = params[i]["paramtype"].strip()
        if pt == "char *":
            if (i + 1 < len(params)
                    and params[i + 1]["paramtype"].strip() in ("int", "uint32", "int32")):
                buffer_pairs.append((i, i + 1))
                i += 2
                continue
            else:
                other_pointers.append(i)
        elif pt.endswith("*") and not pt.startswith("const "):
            other_pointers.append(i)
        i += 1

    if other_pointers:
        return SKIP, []

    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    for idx, p in enumerate(params):
        if idx in skip_indices:
            continue
        if resolve_param_type(p["paramtype"], typedefs, enums) is None:
            return SKIP, []

    if buffer_pairs:
        return STRING_BUFFER, buffer_pairs
    return SIMPLE, []


# ========================================================================
# Python-facing type display
# ========================================================================

_CPP_TO_PYTHON_TYPE = {
    "void": "None",
    "bool": "bool",
    "int": "int",
    "unsigned int": "int",
    "long long": "int",
    "unsigned long long": "int",
    "unsigned short": "int",
    "unsigned char": "int",
    "float": "float",
    "double": "float",
    "std::string": "str",
    "const std::string &": "str",
}


def _cpp_to_python_type(cpp_type):
    return _CPP_TO_PYTHON_TYPE.get(cpp_type, cpp_type)


# ========================================================================
# Callback struct helpers
# ========================================================================

def _build_callback_struct_map(api_data):
    """Build {struct_name: struct_data} for all callback_structs."""
    result = {}
    for s in api_data.get("callback_structs", []):
        result[s["struct"]] = s
    return result


def _field_to_python_type(field_type, typedefs, enums):
    """Map a callback struct field type to its Python display type."""
    ft = field_type.strip()
    # Handle char arrays like "char [256]"
    if ft.startswith("char") and "[" in ft:
        return "str"
    if ft == "bool":
        return "bool"
    if ft == "CSteamID":
        return "int"
    if ft in ("float", "double"):
        return "float"
    if ft.startswith("uint") or ft.startswith("int") or ft == "RTime32":
        return "int"
    if ft in enums:
        return "int"
    if ft in typedefs:
        return _field_to_python_type(typedefs[ft], typedefs, enums)
    # Common Steamworks handles / IDs
    for suffix in ("_t", "Id_t", "Handle", "Handle_t"):
        if ft.endswith(suffix):
            return "int"
    return "int"


def _strip_field_prefix(field_name):
    """Strip m_ prefix from callback field names, then Hungarian."""
    name = field_name
    if name.startswith("m_"):
        name = name[2:]
    return _camel_to_snake(_strip_hungarian(name))


# ========================================================================
# Markdown generation — per-interface API page
# ========================================================================

def _class_name_to_slug(class_name):
    """SteamApps -> steam-apps  (kebab-case for URL slugs)."""
    s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1-\2", class_name)
    s = re.sub(r"([a-z\d])([A-Z])", r"\1-\2", s)
    return s.lower()


def _make_wrapper_params_for_doc(method, buffer_pairs, typedefs, enums):
    """Build list of (snake_name, python_type, steam_type) for documentation."""
    skip_indices = set()
    for ci, si in buffer_pairs:
        skip_indices.add(ci)
        skip_indices.add(si)

    result = []
    for idx, p in enumerate(method.get("params", [])):
        if idx in skip_indices:
            continue
        resolved = resolve_param_type(p["paramtype"], typedefs, enums)
        if resolved is None:
            continue
        cpp_type, _transform = resolved
        py_type = _cpp_to_python_type(cpp_type)
        snake = steam_param_to_snake(p["paramname"])
        result.append((snake, py_type, p["paramtype"].strip()))
    return result


def generate_interface_page(iface_name, iface_data, iface_cfg, methods_info,
                            typedefs, enums, callback_struct_map, nav_order):
    """Generate the Markdown content for a single interface API page."""
    class_name = iface_cfg["class_name"]
    slug = _class_name_to_slug(class_name)
    description = iface_cfg.get("description", "Wrapper around {}.".format(iface_name))
    # Clean up multi-line descriptions from config
    description = re.sub(r"\s*\n\s*", " ", description).strip()

    lines = []
    lines.append(_GENERATED_COMMENT)
    lines.append("")
    lines.append("---")
    lines.append("layout: default")
    lines.append("title: {}".format(class_name))
    lines.append("parent: API Reference")
    lines.append("nav_order: {}".format(nav_order))
    lines.append("---")
    lines.append("")
    lines.append("# {}".format(class_name))
    lines.append("{: .no_toc }")
    lines.append("")
    lines.append(description)
    lines.append("{: .fs-5 .fw-300 }")
    lines.append("")
    lines.append("## Table of contents")
    lines.append("{: .no_toc .text-delta }")
    lines.append("")
    lines.append("1. TOC")
    lines.append("{:toc}")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Overview section
    lines.append("## Overview")
    lines.append("")
    lines.append("`{}` wraps the Steamworks `{}` interface.".format(
        class_name, iface_name))
    lines.append("All methods are **static** — call them directly on the class.")
    lines.append("")

    # Links to Valve docs
    iface_short = iface_name.lstrip("I")
    valve_url = "https://partner.steamgames.com/doc/api/{}".format(iface_name)
    lines.append("[Valve documentation for {}]({})".format(iface_name, valve_url))
    lines.append("{: .fs-3 }")
    lines.append("")

    # Example links
    examples = INTERFACE_EXAMPLES.get(class_name, [])
    if examples:
        lines.append("{: .note }")
        example_links = ", ".join(
            "[`{}`](https://github.com/DigitalDescent/panda3d-steamworks/blob/main/examples/{})".format(
                fname, fname)
            for fname, _desc in examples
        )
        lines.append("> See examples: {}".format(example_links))
        lines.append("")

    # Init/Shutdown section (only for lifecycle interface)
    if iface_cfg.get("include_api_lifecycle"):
        lines.append("---")
        lines.append("")
        lines.append("## Initialisation")
        lines.append("")
        lines.append("### `init() -> bool`")
        lines.append("")
        lines.append("Initialise the Steamworks API. Must be called before any other Steamworks method.")
        lines.append("Returns `True` on success, `False` if the Steam client is not running or `steam_appid.txt` is missing.")
        lines.append("")
        lines.append("### `shutdown() -> None`")
        lines.append("")
        lines.append("Shut down the Steamworks API. Call this when your application exits.")
        lines.append("")

    # Group methods by kind for nicer layout
    sync_methods = []
    async_methods = []
    for method, kind, bpairs, ret_info, wrapper_params in methods_info:
        if kind == ASYNC:
            async_methods.append((method, kind, bpairs, ret_info, wrapper_params))
        else:
            sync_methods.append((method, kind, bpairs, ret_info, wrapper_params))

    # Sort each group alphabetically by snake name
    def _sort_key(entry):
        m = entry[0]
        return steam_method_to_snake(m["methodname"], m["returntype"])

    sync_methods.sort(key=_sort_key)
    async_methods.sort(key=_sort_key)

    # Sync methods section
    if sync_methods:
        lines.append("---")
        lines.append("")
        lines.append("## Methods")
        lines.append("")
        for method, kind, bpairs, ret_info, wrapper_params in sync_methods:
            _write_method_section(lines, method, kind, bpairs, ret_info,
                                  wrapper_params, typedefs, enums)

    # Async methods section
    if async_methods:
        lines.append("---")
        lines.append("")
        lines.append("## Async methods")
        lines.append("")
        lines.append("{: .async }")
        lines.append("> Async methods accept a Python callable as their last argument.")
        lines.append("> The callback receives a `dict` with the result fields.")
        lines.append("> You **must** call `SteamCallbackManager.run_callbacks()` each frame.")
        lines.append("")
        for method, kind, bpairs, ret_info, wrapper_params in async_methods:
            _write_method_section(lines, method, kind, bpairs, ret_info,
                                  wrapper_params, typedefs, enums,
                                  callback_struct_map=callback_struct_map)

    # Extra methods section
    extra_methods = iface_cfg.get("extra_methods", [])
    if extra_methods:
        lines.append("---")
        lines.append("")
        lines.append("## Additional methods")
        lines.append("")
        for em in extra_methods:
            _write_extra_method_section(lines, em)

    # Broadcast callbacks section
    broadcast_events = _get_broadcast_events_for_interface(
        iface_name, callback_struct_map, typedefs, enums)
    if broadcast_events:
        lines.append("---")
        lines.append("")
        lines.append("## Broadcast events")
        lines.append("")
        lines.append("These events fire automatically via the Panda3D messenger.")
        lines.append("Listen with `self.accept(\"event-name\", handler)`.")
        lines.append("")
        for event_name, struct_name, fields in broadcast_events:
            lines.append("### `{}`".format(event_name))
            lines.append("")
            lines.append("Fires when Steam dispatches `{}`.".format(struct_name))
            lines.append("")
            if fields:
                lines.append("| Field | Type | Description |")
                lines.append("|:------|:-----|:------------|")
                for fname, ftype in fields:
                    lines.append("| `{}` | `{}` | |".format(fname, ftype))
                lines.append("")

    lines.append("")
    return "\n".join(lines)


def _write_method_section(lines, method, kind, bpairs, ret_info,
                          wrapper_params, typedefs, enums,
                          callback_struct_map=None):
    """Write the markdown for a single method."""
    snake = steam_method_to_snake(method["methodname"], method["returntype"])
    steam_name = method["methodname"]

    # Determine return type display
    if kind == ASYNC:
        py_ret = "int"
        ret_note = "Returns a call handle (`0` on failure)."
    elif kind == STRING_BUFFER:
        py_ret = "str"
        ret_note = ""
    else:
        cpp_ret = ret_info[0]
        py_ret = _cpp_to_python_type(cpp_ret)
        ret_note = ""

    # Build parameter docs
    doc_params = _make_wrapper_params_for_doc(method, bpairs, typedefs, enums)

    # Build signature
    param_sig_parts = ["{}: {}".format(pn, pt) for pn, pt, _st in doc_params]
    if kind == ASYNC:
        param_sig_parts.append("callback: Callable")
    param_sig = ", ".join(param_sig_parts)

    lines.append("### `{}({}) -> {}`".format(snake, param_sig, py_ret))
    lines.append("")

    # Original Steam method name
    lines.append("Wraps `{}::{}`.".format(
        method.get("_iface_name", "ISteam*"), steam_name))
    lines.append("")

    if ret_note:
        lines.append(ret_note)
        lines.append("")

    # Parameter table
    if doc_params or kind == ASYNC:
        lines.append("| Parameter | Type | Steam type |")
        lines.append("|:----------|:-----|:-----------|")
        for pn, pt, st in doc_params:
            lines.append("| `{}` | `{}` | `{}` |".format(pn, pt, st))
        if kind == ASYNC:
            lines.append("| `callback` | `Callable` | — |")
        lines.append("")

    # Async callback result fields
    if kind == ASYNC and callback_struct_map:
        callresult = method.get("callresult", "")
        if callresult and callresult in callback_struct_map:
            struct = callback_struct_map[callresult]
            fields = struct.get("fields", [])
            if fields:
                lines.append("**Callback result fields:**")
                lines.append("")
                lines.append("| Key | Type |")
                lines.append("|:----|:-----|")
                for f in fields:
                    fname = _strip_field_prefix(f["fieldname"])
                    ftype = _field_to_python_type(
                        f["fieldtype"], {}, set())
                    lines.append("| `{}` | `{}` |".format(fname, ftype))
                lines.append("")

    lines.append("")


def _write_extra_method_section(lines, em):
    """Write markdown for an extra (hand-written) method."""
    name = em.get("name", "method")
    comment = em.get("comment", "")
    decl = em.get("declaration", "")

    # Parse declaration for display: "bool file_write(const std::string &file, ...)"
    # Just display the name and comment
    lines.append("### `{}`".format(name))
    lines.append("")
    if comment:
        lines.append(comment)
        lines.append("")
    if decl:
        lines.append("```cpp")
        lines.append(decl)
        lines.append("```")
        lines.append("")


def _get_broadcast_events_for_interface(iface_name, callback_struct_map,
                                        typedefs, enums):
    """Return broadcast events associated with an interface.

    We map callbacks to interfaces based on Valve's callback ID ranges.
    This is a best-effort mapping — some callbacks span interfaces.
    """
    broadcast_list = getattr(cfg, 'BROADCAST_CALLBACKS', [])
    prefix = getattr(cfg, 'BROADCAST_EVENT_PREFIX', 'Steam-')

    # Map callback ID ranges to interface names
    # See: https://partner.steamgames.com/doc/api
    _CALLBACK_RANGES = {
        range(100, 200): "ISteamUser",
        range(300, 400): "ISteamFriends",
        range(500, 600): "ISteamMatchmaking",
        range(700, 800): "ISteamUtils",
        range(1000, 1100): "ISteamRemoteStorage",
        range(1100, 1200): "ISteamUserStats",
        range(1200, 1300): "ISteamNetworking",
        range(1300, 1400): "ISteamApps",
        range(2100, 2200): "ISteamScreenshots",
        range(2300, 2400): "ISteamMusic",
        range(3400, 3500): "ISteamUGC",
        range(3900, 4000): "ISteamHTMLSurface",
        range(4100, 4200): "ISteamInventory",
        range(4400, 4500): "ISteamParties",
        range(4500, 4600): "ISteamRemotePlay",
        range(4700, 4800): "ISteamTimeline",
    }

    result = []
    for struct_name in broadcast_list:
        struct = callback_struct_map.get(struct_name)
        if not struct:
            continue

        cb_id = struct.get("callback_id", 0)
        owner_iface = None
        for id_range, iface in _CALLBACK_RANGES.items():
            if cb_id in id_range:
                owner_iface = iface
                break

        if owner_iface != iface_name:
            continue

        # Build event name: strip _t suffix, add prefix
        event_suffix = struct_name
        if event_suffix.endswith("_t"):
            event_suffix = event_suffix[:-2]
        event_name = "{}{}".format(prefix, event_suffix)

        fields = []
        for f in struct.get("fields", []):
            fname = _strip_field_prefix(f["fieldname"])
            ftype = _field_to_python_type(f["fieldtype"], typedefs, enums)
            fields.append((fname, ftype))

        result.append((event_name, struct_name, fields))

    return result


# ========================================================================
# API index page generation
# ========================================================================

def generate_api_index(generated_interfaces):
    """Generate the docs/api/index.md page."""
    # Build a lookup of class_name -> slug
    slug_map = {}
    for class_name in generated_interfaces:
        slug_map[class_name] = _class_name_to_slug(class_name)

    lines = []
    lines.append(_GENERATED_COMMENT)
    lines.append("")
    lines.append("---")
    lines.append("layout: default")
    lines.append("title: API Reference")
    lines.append("nav_order: 3")
    lines.append("has_children: true")
    lines.append("---")
    lines.append("")
    lines.append("# API Reference")
    lines.append("{: .no_toc }")
    lines.append("")
    lines.append("Complete reference for all panda3d-steamworks classes. "
                 "Every class is **static-only** — call methods directly on "
                 "the class rather than creating instances.")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Conventions
    lines.append("## Conventions")
    lines.append("")
    lines.append("### Async methods")
    lines.append("")
    lines.append("Methods marked with **async** accept a Python callable as "
                 "their last argument. The callback receives a `dict` "
                 "containing the result fields. Returns a call handle "
                 "(`int`, `0` on failure).")
    lines.append("")
    lines.append("{: .warning }")
    lines.append("> You **must** call `SteamCallbackManager.run_callbacks()` "
                 "every frame for async callbacks to fire.")
    lines.append("")
    lines.append("### Broadcast events")
    lines.append("")
    lines.append("Some Steam events are delivered as Panda3D messenger events. "
                 "Use `self.accept(\"event-name\", handler)` in any "
                 "`DirectObject` subclass to listen for them.")
    lines.append("")
    lines.append("### Steam IDs")
    lines.append("")
    lines.append("Steam IDs are represented as `int` (64-bit unsigned). "
                 "In Python this is a regular integer.")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Classes by category
    lines.append("## Classes by category")
    lines.append("")
    for cat_name, cat_classes in INTERFACE_CATEGORIES:
        lines.append("### {}".format(cat_name))
        for cls in cat_classes:
            if cls in slug_map:
                lines.append("- [{}]({}) — {}".format(
                    cls, slug_map[cls],
                    _get_short_description(cls)))
            # Skip classes that weren't generated
        lines.append("")

    # Also include SteamCallbackManager
    lines.append("### Callback System")
    lines.append("- **SteamCallbackManager** — Frame-pump for both async and broadcast callbacks")
    lines.append("")

    lines.append("")
    return "\n".join(lines)


def _get_short_description(class_name):
    """Return a one-line description for an interface in the index."""
    _DESCRIPTIONS = {
        "SteamApps": "App ownership, DLC, language, installation",
        "SteamUser": "Current user identity, authentication, licensing",
        "SteamUtils": "Overlay, device info, text filtering, app ID",
        "SteamFriends": "Friends, overlay, rich presence, clans",
        "SteamParties": "Steam Parties / beacon system",
        "SteamUserStats": "Achievements, stats, leaderboards",
        "SteamMatchmaking": "Lobby creation, discovery, filtering",
        "SteamMatchmakingServers": "Game server browser queries",
        "SteamNetworkingSockets": "Modern relay-based networking",
        "SteamNetworkingMessages": "Connectionless networking messages",
        "SteamNetworkingUtils": "Networking diagnostics and config",
        "SteamNetworking": "Legacy peer-to-peer networking",
        "SteamRemoteStorage": "Cloud saves, file read/write",
        "SteamUGC": "Workshop / user-generated content",
        "SteamInput": "Modern controller input with glyphs",
        "SteamController": "Legacy controller API",
        "SteamGameServer": "Dedicated server registration",
        "SteamGameServerStats": "Server-side user stats and achievements",
        "SteamInventory": "In-game items and microtransactions",
        "SteamHTMLSurface": "Embedded Chromium browser",
        "SteamScreenshots": "Screenshot capture and tagging",
        "SteamMusic": "Steam music player control",
        "SteamVideo": "Steam video playback",
        "SteamTimeline": "Game recording timeline events",
        "SteamRemotePlay": "Remote Play Together sessions",
        "SteamParentalSettings": "Parental control queries",
        "SteamHTTP": "HTTP request API",
    }
    return _DESCRIPTIONS.get(class_name, "Steamworks interface wrapper")


# ========================================================================
# Main entry point
# ========================================================================

def run_docs_codegen(root_dir=None, check_only=False):
    """Generate documentation.  Returns a list of generated file paths."""
    if root_dir is None:
        root_dir = _ROOT_DIR

    json_path = os.path.join(root_dir, cfg.STEAM_API_JSON)
    output_dir = os.path.join(root_dir, DOCS_API_DIR)

    if not os.path.isdir(output_dir) and not check_only:
        os.makedirs(output_dir)

    # Load the API definition
    with open(json_path, "r", encoding="utf-8") as f:
        api_data = json.load(f)

    typedefs = _build_typedef_map(api_data)
    enums = _build_enum_set(api_data)
    callback_struct_map = _build_callback_struct_map(api_data)

    generated_files = []
    stale_files = []
    generated_interfaces = []  # class names that got generated

    nav_order = 1

    for iface_data in api_data.get("interfaces", []):
        iface_name = iface_data["classname"]

        if iface_name in cfg.SKIP_INTERFACES:
            continue

        accessors = iface_data.get("accessors", [])
        if not accessors and iface_name != cfg.LIFECYCLE_INTERFACE:
            continue

        # Derive class name
        class_name = iface_name
        if class_name.startswith("I"):
            class_name = class_name[1:]

        overrides = cfg.INTERFACE_OVERRIDES.get(iface_name, {})
        iface_cfg = {
            "class_name": overrides.get("class_name", class_name),
            "description": overrides.get(
                "description",
                "Wrapper around {}.".format(iface_name),
            ),
            "include_api_lifecycle": (iface_name == cfg.LIFECYCLE_INTERFACE),
            "skip_methods": overrides.get("skip_methods", []),
            "buffer_sizes": overrides.get("buffer_sizes", {}),
            "extra_includes": overrides.get("extra_includes", []),
            "extra_methods": overrides.get("extra_methods", []),
        }

        class_name = iface_cfg["class_name"]
        skip_set = set(iface_cfg.get("skip_methods", []))

        # Classify and filter methods (same logic as codegen.py)
        methods_info = []
        for method in iface_data.get("methods", []):
            if method["methodname"] in skip_set:
                continue
            kind, bpairs = classify_method(method, typedefs, enums)
            if kind == SKIP:
                continue

            ret_info = resolve_return_type(method["returntype"], typedefs, enums)
            # Build wrapper params (excluding buffer pairs)
            skip_indices = set()
            for ci, si in bpairs:
                skip_indices.add(ci)
                skip_indices.add(si)
            wrapper_params = []
            for idx, p in enumerate(method.get("params", [])):
                if idx in skip_indices:
                    continue
                resolved = resolve_param_type(p["paramtype"], typedefs, enums)
                if resolved is None:
                    continue
                cpp_type, transform = resolved
                pname = steam_param_to_snake(p["paramname"])
                wrapper_params.append((pname, cpp_type, transform))

            # Annotate method with interface name for display
            method["_iface_name"] = iface_name
            methods_info.append((method, kind, bpairs, ret_info, wrapper_params))

        if not methods_info and not iface_cfg.get("include_api_lifecycle"):
            continue

        generated_interfaces.append(class_name)

        # Generate the page
        content = generate_interface_page(
            iface_name, iface_data, iface_cfg, methods_info,
            typedefs, enums, callback_struct_map, nav_order)

        slug = _class_name_to_slug(class_name)
        page_path = os.path.join(output_dir, slug + ".md")

        if check_only:
            if not os.path.isfile(page_path):
                stale_files.append(page_path)
            else:
                with open(page_path, "r", encoding="utf-8") as f:
                    if f.read() != content:
                        stale_files.append(page_path)
        else:
            _write_if_changed(page_path, content)
            generated_files.append(page_path)

        nav_order += 1

    # Generate the API index page
    index_content = generate_api_index(generated_interfaces)
    index_path = os.path.join(output_dir, "index.md")

    if check_only:
        if not os.path.isfile(index_path):
            stale_files.append(index_path)
        else:
            with open(index_path, "r", encoding="utf-8") as f:
                if f.read() != index_content:
                    stale_files.append(index_path)
        return stale_files
    else:
        _write_if_changed(index_path, index_content)
        generated_files.append(index_path)

    return generated_files


def _write_if_changed(path, content):
    """Write content to path only if the file doesn't already match."""
    if os.path.isfile(path):
        with open(path, "r", encoding="utf-8") as f:
            if f.read() == content:
                return
    with open(path, "w", newline="\n", encoding="utf-8") as f:
        f.write(content)
    print("  generated: {}".format(os.path.relpath(path, _ROOT_DIR)))


# ========================================================================
# CLI
# ========================================================================

def main():
    check_only = "--check" in sys.argv

    if check_only:
        stale = run_docs_codegen(check_only=True)
        if stale:
            print("The following doc files are out of date:")
            for p in stale:
                print("  " + p)
            sys.exit(1)
        else:
            print("All generated doc files are up to date.")
            sys.exit(0)
    else:
        print("Generating API documentation ...")
        files = run_docs_codegen()
        if files:
            print("Generated {} file(s).".format(len(files)))
        else:
            print("All doc files already up to date.")


if __name__ == "__main__":
    main()
