// ======================================================================
// AUTO-GENERATED by scripts/codegen.py - DO NOT EDIT BY HAND.
// Re-generate with:  ppython scripts/codegen.py
// ======================================================================

#include "steamTimeline.h"

// Guard everything below from interrogate's parser.
#ifndef CPPPARSER

#include <steam/steam_api.h>
#include <steam/steam_api_flat.h>

// Helper: returns the ISteamTimeline interface pointer, or nullptr if not initialized.
static ISteamTimeline *_get_steam_timeline() {
  return SteamAPI_SteamTimeline();
}

// Forward declarations for async call-result registration
extern void _steam_async_call_SteamTimelineGamePhaseRecordingExists_t(SteamAPICall_t, PyObject *);

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::set_timeline_tooltip
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::set_timeline_tooltip(const std::string & description, float time_delta) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->SetTimelineTooltip(description.c_str(), time_delta);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::clear_timeline_tooltip
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::clear_timeline_tooltip(float time_delta) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->ClearTimelineTooltip(time_delta);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::set_timeline_game_mode
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::set_timeline_game_mode(int mode) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->SetTimelineGameMode(static_cast<ETimelineGameMode>(mode));
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::start_game_phase
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::start_game_phase() {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->StartGamePhase();
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::end_game_phase
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::end_game_phase() {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->EndGamePhase();
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::set_game_phase_id
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::set_game_phase_id(const std::string & phase_id) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->SetGamePhaseID(phase_id.c_str());
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::does_game_phase_recording_exist
//       Access: Published, Static
//  Description: Async. Invokes callback(dict) on completion.
////////////////////////////////////////////////////////////////////
unsigned long long SteamTimeline::does_game_phase_recording_exist(const std::string & phase_id, PyObject *callback) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (!iface) return 0;
  SteamAPICall_t call = iface->DoesGamePhaseRecordingExist(phase_id.c_str());
  if (call == k_uAPICallInvalid) return 0;
  if (callback && callback != Py_None && PyCallable_Check(callback)) {
    _steam_async_call_SteamTimelineGamePhaseRecordingExists_t(call, callback);
  }
  return (unsigned long long)call;
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::add_game_phase_tag
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::add_game_phase_tag(const std::string & tag_name, const std::string & tag_icon, const std::string & tag_group, unsigned int priority) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->AddGamePhaseTag(tag_name.c_str(), tag_icon.c_str(), tag_group.c_str(), priority);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::set_game_phase_attribute
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::set_game_phase_attribute(const std::string & attribute_group, const std::string & attribute_value, unsigned int priority) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->SetGamePhaseAttribute(attribute_group.c_str(), attribute_value.c_str(), priority);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamTimeline::open_overlay_to_game_phase
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamTimeline::open_overlay_to_game_phase(const std::string & phase_id) {
  ISteamTimeline *iface = _get_steam_timeline();
  if (iface) iface->OpenOverlayToGamePhase(phase_id.c_str());
}

#endif  // CPPPARSER
