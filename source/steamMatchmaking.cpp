// ======================================================================
// AUTO-GENERATED by scripts/codegen.py - DO NOT EDIT BY HAND.
// Re-generate with:  ppython scripts/codegen.py
// ======================================================================

#include "steamMatchmaking.h"

// Guard everything below from interrogate's parser.
#ifndef CPPPARSER

#include <steam/steam_api.h>
#include <steam/steam_api_flat.h>

// Helper: returns the ISteamMatchmaking interface pointer, or nullptr if not initialized.
static ISteamMatchmaking *_get_steam_matchmaking() {
  return SteamAPI_SteamMatchmaking();
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::get_favorite_game_count
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
int SteamMatchmaking::get_favorite_game_count() {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (!iface) return 0;
  return iface->GetFavoriteGameCount();
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_favorite_game
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
int SteamMatchmaking::add_favorite_game(unsigned int app_id, unsigned int ip, unsigned short conn_port, unsigned short query_port, unsigned int flags, unsigned int r_time32_last_played_on_server) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (!iface) return 0;
  return iface->AddFavoriteGame(app_id, ip, conn_port, query_port, flags, r_time32_last_played_on_server);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::remove_favorite_game
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
bool SteamMatchmaking::remove_favorite_game(unsigned int app_id, unsigned int ip, unsigned short conn_port, unsigned short query_port, unsigned int flags) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (!iface) return false;
  return iface->RemoveFavoriteGame(app_id, ip, conn_port, query_port, flags);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_string_filter
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_string_filter(const std::string & key_to_match, const std::string & value_to_match, int comparison_type) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListStringFilter(key_to_match.c_str(), value_to_match.c_str(), static_cast<ELobbyComparison>(comparison_type));
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_numerical_filter
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_numerical_filter(const std::string & key_to_match, int value_to_match, int comparison_type) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListNumericalFilter(key_to_match.c_str(), value_to_match, static_cast<ELobbyComparison>(comparison_type));
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_near_value_filter
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_near_value_filter(const std::string & key_to_match, int value_to_be_close_to) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListNearValueFilter(key_to_match.c_str(), value_to_be_close_to);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_filter_slots_available
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_filter_slots_available(int slots_available) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListFilterSlotsAvailable(slots_available);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_distance_filter
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_distance_filter(int lobby_distance_filter) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListDistanceFilter(static_cast<ELobbyDistanceFilter>(lobby_distance_filter));
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::add_request_lobby_list_result_count_filter
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
void SteamMatchmaking::add_request_lobby_list_result_count_filter(int max_results) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (iface) iface->AddRequestLobbyListResultCountFilter(max_results);
}

////////////////////////////////////////////////////////////////////
//     Function: SteamMatchmaking::get_lobby_by_index
//       Access: Published, Static
////////////////////////////////////////////////////////////////////
unsigned long long SteamMatchmaking::get_lobby_by_index(int lobby) {
  ISteamMatchmaking *iface = _get_steam_matchmaking();
  if (!iface) return 0;
  return iface->GetLobbyByIndex(lobby).ConvertToUint64();
}

#endif  // CPPPARSER
