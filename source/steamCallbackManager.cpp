// ======================================================================
// AUTO-GENERATED by scripts/codegen.py - DO NOT EDIT BY HAND.
// Re-generate with:  ppython scripts/codegen.py
// ======================================================================

#include "steamCallbackManager.h"

// Guard implementation from interrogate.
#ifndef CPPPARSER

#include <steam/steam_api.h>
#include <steam/steam_gameserver.h>
#include <Python.h>
#include <vector>
#include <string>

// ------------------------------------------------------------
// Async result handler: AddAppDependencyResult_t
// ------------------------------------------------------------

struct _PendingCall_AddAppDependencyResult_t {
  CCallResult<_PendingCall_AddAppDependencyResult_t, AddAppDependencyResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_AddAppDependencyResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_AddAppDependencyResult_t::OnComplete);
  }

  ~_PendingCall_AddAppDependencyResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(AddAppDependencyResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nAppID));
      PyDict_SetItemString(dict, "app_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_AddAppDependencyResult_t*> _pending_AddAppDependencyResult_t;

void _steam_async_call_AddAppDependencyResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_AddAppDependencyResult_t(call, callback);
  _pending_AddAppDependencyResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: AddUGCDependencyResult_t
// ------------------------------------------------------------

struct _PendingCall_AddUGCDependencyResult_t {
  CCallResult<_PendingCall_AddUGCDependencyResult_t, AddUGCDependencyResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_AddUGCDependencyResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_AddUGCDependencyResult_t::OnComplete);
  }

  ~_PendingCall_AddUGCDependencyResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(AddUGCDependencyResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nChildPublishedFileId));
      PyDict_SetItemString(dict, "child_published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_AddUGCDependencyResult_t*> _pending_AddUGCDependencyResult_t;

void _steam_async_call_AddUGCDependencyResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_AddUGCDependencyResult_t(call, callback);
  _pending_AddUGCDependencyResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: AssociateWithClanResult_t
// ------------------------------------------------------------

struct _PendingCall_AssociateWithClanResult_t {
  CCallResult<_PendingCall_AssociateWithClanResult_t, AssociateWithClanResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_AssociateWithClanResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_AssociateWithClanResult_t::OnComplete);
  }

  ~_PendingCall_AssociateWithClanResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(AssociateWithClanResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_AssociateWithClanResult_t*> _pending_AssociateWithClanResult_t;

void _steam_async_call_AssociateWithClanResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_AssociateWithClanResult_t(call, callback);
  _pending_AssociateWithClanResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: ChangeNumOpenSlotsCallback_t
// ------------------------------------------------------------

struct _PendingCall_ChangeNumOpenSlotsCallback_t {
  CCallResult<_PendingCall_ChangeNumOpenSlotsCallback_t, ChangeNumOpenSlotsCallback_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_ChangeNumOpenSlotsCallback_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_ChangeNumOpenSlotsCallback_t::OnComplete);
  }

  ~_PendingCall_ChangeNumOpenSlotsCallback_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(ChangeNumOpenSlotsCallback_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_ChangeNumOpenSlotsCallback_t*> _pending_ChangeNumOpenSlotsCallback_t;

void _steam_async_call_ChangeNumOpenSlotsCallback_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_ChangeNumOpenSlotsCallback_t(call, callback);
  _pending_ChangeNumOpenSlotsCallback_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: CheckFileSignature_t
// ------------------------------------------------------------

struct _PendingCall_CheckFileSignature_t {
  CCallResult<_PendingCall_CheckFileSignature_t, CheckFileSignature_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_CheckFileSignature_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_CheckFileSignature_t::OnComplete);
  }

  ~_PendingCall_CheckFileSignature_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(CheckFileSignature_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eCheckFileSignature));
      PyDict_SetItemString(dict, "check_file_signature", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_CheckFileSignature_t*> _pending_CheckFileSignature_t;

void _steam_async_call_CheckFileSignature_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_CheckFileSignature_t(call, callback);
  _pending_CheckFileSignature_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: ClanOfficerListResponse_t
// ------------------------------------------------------------

struct _PendingCall_ClanOfficerListResponse_t {
  CCallResult<_PendingCall_ClanOfficerListResponse_t, ClanOfficerListResponse_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_ClanOfficerListResponse_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_ClanOfficerListResponse_t::OnComplete);
  }

  ~_PendingCall_ClanOfficerListResponse_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(ClanOfficerListResponse_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((pResult->m_steamIDClan).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_clan", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cOfficers));
      PyDict_SetItemString(dict, "officers", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_bSuccess));
      PyDict_SetItemString(dict, "success", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_ClanOfficerListResponse_t*> _pending_ClanOfficerListResponse_t;

void _steam_async_call_ClanOfficerListResponse_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_ClanOfficerListResponse_t(call, callback);
  _pending_ClanOfficerListResponse_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: ComputeNewPlayerCompatibilityResult_t
// ------------------------------------------------------------

struct _PendingCall_ComputeNewPlayerCompatibilityResult_t {
  CCallResult<_PendingCall_ComputeNewPlayerCompatibilityResult_t, ComputeNewPlayerCompatibilityResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_ComputeNewPlayerCompatibilityResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_ComputeNewPlayerCompatibilityResult_t::OnComplete);
  }

  ~_PendingCall_ComputeNewPlayerCompatibilityResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(ComputeNewPlayerCompatibilityResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cPlayersThatDontLikeCandidate));
      PyDict_SetItemString(dict, "players_that_dont_like_candidate", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cPlayersThatCandidateDoesntLike));
      PyDict_SetItemString(dict, "players_that_candidate_doesnt_like", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cClanPlayersThatDontLikeCandidate));
      PyDict_SetItemString(dict, "clan_players_that_dont_like_candidate", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_SteamIDCandidate).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_candidate", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_ComputeNewPlayerCompatibilityResult_t*> _pending_ComputeNewPlayerCompatibilityResult_t;

void _steam_async_call_ComputeNewPlayerCompatibilityResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_ComputeNewPlayerCompatibilityResult_t(call, callback);
  _pending_ComputeNewPlayerCompatibilityResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: CreateBeaconCallback_t
// ------------------------------------------------------------

struct _PendingCall_CreateBeaconCallback_t {
  CCallResult<_PendingCall_CreateBeaconCallback_t, CreateBeaconCallback_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_CreateBeaconCallback_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_CreateBeaconCallback_t::OnComplete);
  }

  ~_PendingCall_CreateBeaconCallback_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(CreateBeaconCallback_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulBeaconID));
      PyDict_SetItemString(dict, "beacon_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_CreateBeaconCallback_t*> _pending_CreateBeaconCallback_t;

void _steam_async_call_CreateBeaconCallback_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_CreateBeaconCallback_t(call, callback);
  _pending_CreateBeaconCallback_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: CreateItemResult_t
// ------------------------------------------------------------

struct _PendingCall_CreateItemResult_t {
  CCallResult<_PendingCall_CreateItemResult_t, CreateItemResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_CreateItemResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_CreateItemResult_t::OnComplete);
  }

  ~_PendingCall_CreateItemResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(CreateItemResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bUserNeedsToAcceptWorkshopLegalAgreement));
      PyDict_SetItemString(dict, "user_needs_to_accept_workshop_legal_agreement", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_CreateItemResult_t*> _pending_CreateItemResult_t;

void _steam_async_call_CreateItemResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_CreateItemResult_t(call, callback);
  _pending_CreateItemResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: DeleteItemResult_t
// ------------------------------------------------------------

struct _PendingCall_DeleteItemResult_t {
  CCallResult<_PendingCall_DeleteItemResult_t, DeleteItemResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_DeleteItemResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_DeleteItemResult_t::OnComplete);
  }

  ~_PendingCall_DeleteItemResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(DeleteItemResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_DeleteItemResult_t*> _pending_DeleteItemResult_t;

void _steam_async_call_DeleteItemResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_DeleteItemResult_t(call, callback);
  _pending_DeleteItemResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: DownloadClanActivityCountsResult_t
// ------------------------------------------------------------

struct _PendingCall_DownloadClanActivityCountsResult_t {
  CCallResult<_PendingCall_DownloadClanActivityCountsResult_t, DownloadClanActivityCountsResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_DownloadClanActivityCountsResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_DownloadClanActivityCountsResult_t::OnComplete);
  }

  ~_PendingCall_DownloadClanActivityCountsResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(DownloadClanActivityCountsResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyBool_FromLong((long)(pResult->m_bSuccess));
      PyDict_SetItemString(dict, "success", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_DownloadClanActivityCountsResult_t*> _pending_DownloadClanActivityCountsResult_t;

void _steam_async_call_DownloadClanActivityCountsResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_DownloadClanActivityCountsResult_t(call, callback);
  _pending_DownloadClanActivityCountsResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: DurationControl_t
// ------------------------------------------------------------

struct _PendingCall_DurationControl_t {
  CCallResult<_PendingCall_DurationControl_t, DurationControl_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_DurationControl_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_DurationControl_t::OnComplete);
  }

  ~_PendingCall_DurationControl_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(DurationControl_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_appid));
      PyDict_SetItemString(dict, "appid", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bApplicable));
      PyDict_SetItemString(dict, "applicable", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_csecsLast5h));
      PyDict_SetItemString(dict, "csecs_last5h", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_progress));
      PyDict_SetItemString(dict, "progress", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_notification));
      PyDict_SetItemString(dict, "notification", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_csecsToday));
      PyDict_SetItemString(dict, "csecs_today", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_csecsRemaining));
      PyDict_SetItemString(dict, "csecs_remaining", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_DurationControl_t*> _pending_DurationControl_t;

void _steam_async_call_DurationControl_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_DurationControl_t(call, callback);
  _pending_DurationControl_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: EncryptedAppTicketResponse_t
// ------------------------------------------------------------

struct _PendingCall_EncryptedAppTicketResponse_t {
  CCallResult<_PendingCall_EncryptedAppTicketResponse_t, EncryptedAppTicketResponse_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_EncryptedAppTicketResponse_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_EncryptedAppTicketResponse_t::OnComplete);
  }

  ~_PendingCall_EncryptedAppTicketResponse_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(EncryptedAppTicketResponse_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_EncryptedAppTicketResponse_t*> _pending_EncryptedAppTicketResponse_t;

void _steam_async_call_EncryptedAppTicketResponse_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_EncryptedAppTicketResponse_t(call, callback);
  _pending_EncryptedAppTicketResponse_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: EquippedProfileItems_t
// ------------------------------------------------------------

struct _PendingCall_EquippedProfileItems_t {
  CCallResult<_PendingCall_EquippedProfileItems_t, EquippedProfileItems_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_EquippedProfileItems_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_EquippedProfileItems_t::OnComplete);
  }

  ~_PendingCall_EquippedProfileItems_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(EquippedProfileItems_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamID).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bHasAnimatedAvatar));
      PyDict_SetItemString(dict, "has_animated_avatar", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bHasAvatarFrame));
      PyDict_SetItemString(dict, "has_avatar_frame", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bHasProfileModifier));
      PyDict_SetItemString(dict, "has_profile_modifier", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bHasProfileBackground));
      PyDict_SetItemString(dict, "has_profile_background", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bHasMiniProfileBackground));
      PyDict_SetItemString(dict, "has_mini_profile_background", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bFromCache));
      PyDict_SetItemString(dict, "from_cache", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_EquippedProfileItems_t*> _pending_EquippedProfileItems_t;

void _steam_async_call_EquippedProfileItems_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_EquippedProfileItems_t(call, callback);
  _pending_EquippedProfileItems_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: FileDetailsResult_t
// ------------------------------------------------------------

struct _PendingCall_FileDetailsResult_t {
  CCallResult<_PendingCall_FileDetailsResult_t, FileDetailsResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_FileDetailsResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_FileDetailsResult_t::OnComplete);
  }

  ~_PendingCall_FileDetailsResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(FileDetailsResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulFileSize));
      PyDict_SetItemString(dict, "file_size", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unFlags));
      PyDict_SetItemString(dict, "flags", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_FileDetailsResult_t*> _pending_FileDetailsResult_t;

void _steam_async_call_FileDetailsResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_FileDetailsResult_t(call, callback);
  _pending_FileDetailsResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: FriendsEnumerateFollowingList_t
// ------------------------------------------------------------

struct _PendingCall_FriendsEnumerateFollowingList_t {
  CCallResult<_PendingCall_FriendsEnumerateFollowingList_t, FriendsEnumerateFollowingList_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_FriendsEnumerateFollowingList_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_FriendsEnumerateFollowingList_t::OnComplete);
  }

  ~_PendingCall_FriendsEnumerateFollowingList_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(FriendsEnumerateFollowingList_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nResultsReturned));
      PyDict_SetItemString(dict, "results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nTotalResultCount));
      PyDict_SetItemString(dict, "total_result_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_FriendsEnumerateFollowingList_t*> _pending_FriendsEnumerateFollowingList_t;

void _steam_async_call_FriendsEnumerateFollowingList_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_FriendsEnumerateFollowingList_t(call, callback);
  _pending_FriendsEnumerateFollowingList_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: FriendsGetFollowerCount_t
// ------------------------------------------------------------

struct _PendingCall_FriendsGetFollowerCount_t {
  CCallResult<_PendingCall_FriendsGetFollowerCount_t, FriendsGetFollowerCount_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_FriendsGetFollowerCount_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_FriendsGetFollowerCount_t::OnComplete);
  }

  ~_PendingCall_FriendsGetFollowerCount_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(FriendsGetFollowerCount_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamID).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nCount));
      PyDict_SetItemString(dict, "count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_FriendsGetFollowerCount_t*> _pending_FriendsGetFollowerCount_t;

void _steam_async_call_FriendsGetFollowerCount_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_FriendsGetFollowerCount_t(call, callback);
  _pending_FriendsGetFollowerCount_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: FriendsIsFollowing_t
// ------------------------------------------------------------

struct _PendingCall_FriendsIsFollowing_t {
  CCallResult<_PendingCall_FriendsIsFollowing_t, FriendsIsFollowing_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_FriendsIsFollowing_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_FriendsIsFollowing_t::OnComplete);
  }

  ~_PendingCall_FriendsIsFollowing_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(FriendsIsFollowing_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamID).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bIsFollowing));
      PyDict_SetItemString(dict, "is_following", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_FriendsIsFollowing_t*> _pending_FriendsIsFollowing_t;

void _steam_async_call_FriendsIsFollowing_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_FriendsIsFollowing_t(call, callback);
  _pending_FriendsIsFollowing_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GSReputation_t
// ------------------------------------------------------------

struct _PendingCall_GSReputation_t {
  CCallResult<_PendingCall_GSReputation_t, GSReputation_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GSReputation_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GSReputation_t::OnComplete);
  }

  ~_PendingCall_GSReputation_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GSReputation_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unReputationScore));
      PyDict_SetItemString(dict, "reputation_score", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bBanned));
      PyDict_SetItemString(dict, "banned", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unBannedIP));
      PyDict_SetItemString(dict, "banned_ip", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_usBannedPort));
      PyDict_SetItemString(dict, "us_banned_port", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulBannedGameID));
      PyDict_SetItemString(dict, "banned_game_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unBanExpires));
      PyDict_SetItemString(dict, "ban_expires", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GSReputation_t*> _pending_GSReputation_t;

void _steam_async_call_GSReputation_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GSReputation_t(call, callback);
  _pending_GSReputation_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GSStatsReceived_t
// ------------------------------------------------------------

struct _PendingCall_GSStatsReceived_t {
  CCallResult<_PendingCall_GSStatsReceived_t, GSStatsReceived_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GSStatsReceived_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GSStatsReceived_t::OnComplete);
  }

  ~_PendingCall_GSStatsReceived_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GSStatsReceived_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamIDUser).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_user", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GSStatsReceived_t*> _pending_GSStatsReceived_t;

void _steam_async_call_GSStatsReceived_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GSStatsReceived_t(call, callback);
  _pending_GSStatsReceived_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GSStatsStored_t
// ------------------------------------------------------------

struct _PendingCall_GSStatsStored_t {
  CCallResult<_PendingCall_GSStatsStored_t, GSStatsStored_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GSStatsStored_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GSStatsStored_t::OnComplete);
  }

  ~_PendingCall_GSStatsStored_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GSStatsStored_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamIDUser).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_user", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GSStatsStored_t*> _pending_GSStatsStored_t;

void _steam_async_call_GSStatsStored_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GSStatsStored_t(call, callback);
  _pending_GSStatsStored_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GetAppDependenciesResult_t
// ------------------------------------------------------------

struct _PendingCall_GetAppDependenciesResult_t {
  CCallResult<_PendingCall_GetAppDependenciesResult_t, GetAppDependenciesResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GetAppDependenciesResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GetAppDependenciesResult_t::OnComplete);
  }

  ~_PendingCall_GetAppDependenciesResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GetAppDependenciesResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nNumAppDependencies));
      PyDict_SetItemString(dict, "num_app_dependencies", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nTotalNumAppDependencies));
      PyDict_SetItemString(dict, "total_num_app_dependencies", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GetAppDependenciesResult_t*> _pending_GetAppDependenciesResult_t;

void _steam_async_call_GetAppDependenciesResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GetAppDependenciesResult_t(call, callback);
  _pending_GetAppDependenciesResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GetUserItemVoteResult_t
// ------------------------------------------------------------

struct _PendingCall_GetUserItemVoteResult_t {
  CCallResult<_PendingCall_GetUserItemVoteResult_t, GetUserItemVoteResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GetUserItemVoteResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GetUserItemVoteResult_t::OnComplete);
  }

  ~_PendingCall_GetUserItemVoteResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GetUserItemVoteResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bVotedUp));
      PyDict_SetItemString(dict, "voted_up", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bVotedDown));
      PyDict_SetItemString(dict, "voted_down", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bVoteSkipped));
      PyDict_SetItemString(dict, "vote_skipped", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GetUserItemVoteResult_t*> _pending_GetUserItemVoteResult_t;

void _steam_async_call_GetUserItemVoteResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GetUserItemVoteResult_t(call, callback);
  _pending_GetUserItemVoteResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GlobalAchievementPercentagesReady_t
// ------------------------------------------------------------

struct _PendingCall_GlobalAchievementPercentagesReady_t {
  CCallResult<_PendingCall_GlobalAchievementPercentagesReady_t, GlobalAchievementPercentagesReady_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GlobalAchievementPercentagesReady_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GlobalAchievementPercentagesReady_t::OnComplete);
  }

  ~_PendingCall_GlobalAchievementPercentagesReady_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GlobalAchievementPercentagesReady_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nGameID));
      PyDict_SetItemString(dict, "game_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GlobalAchievementPercentagesReady_t*> _pending_GlobalAchievementPercentagesReady_t;

void _steam_async_call_GlobalAchievementPercentagesReady_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GlobalAchievementPercentagesReady_t(call, callback);
  _pending_GlobalAchievementPercentagesReady_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: GlobalStatsReceived_t
// ------------------------------------------------------------

struct _PendingCall_GlobalStatsReceived_t {
  CCallResult<_PendingCall_GlobalStatsReceived_t, GlobalStatsReceived_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_GlobalStatsReceived_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_GlobalStatsReceived_t::OnComplete);
  }

  ~_PendingCall_GlobalStatsReceived_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(GlobalStatsReceived_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nGameID));
      PyDict_SetItemString(dict, "game_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_GlobalStatsReceived_t*> _pending_GlobalStatsReceived_t;

void _steam_async_call_GlobalStatsReceived_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_GlobalStatsReceived_t(call, callback);
  _pending_GlobalStatsReceived_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: HTML_BrowserReady_t
// ------------------------------------------------------------

struct _PendingCall_HTML_BrowserReady_t {
  CCallResult<_PendingCall_HTML_BrowserReady_t, HTML_BrowserReady_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_HTML_BrowserReady_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_HTML_BrowserReady_t::OnComplete);
  }

  ~_PendingCall_HTML_BrowserReady_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(HTML_BrowserReady_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->unBrowserHandle));
      PyDict_SetItemString(dict, "browser_handle", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_HTML_BrowserReady_t*> _pending_HTML_BrowserReady_t;

void _steam_async_call_HTML_BrowserReady_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_HTML_BrowserReady_t(call, callback);
  _pending_HTML_BrowserReady_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: JoinClanChatRoomCompletionResult_t
// ------------------------------------------------------------

struct _PendingCall_JoinClanChatRoomCompletionResult_t {
  CCallResult<_PendingCall_JoinClanChatRoomCompletionResult_t, JoinClanChatRoomCompletionResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_JoinClanChatRoomCompletionResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_JoinClanChatRoomCompletionResult_t::OnComplete);
  }

  ~_PendingCall_JoinClanChatRoomCompletionResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(JoinClanChatRoomCompletionResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((pResult->m_steamIDClanChat).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_clan_chat", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eChatRoomEnterResponse));
      PyDict_SetItemString(dict, "chat_room_enter_response", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_JoinClanChatRoomCompletionResult_t*> _pending_JoinClanChatRoomCompletionResult_t;

void _steam_async_call_JoinClanChatRoomCompletionResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_JoinClanChatRoomCompletionResult_t(call, callback);
  _pending_JoinClanChatRoomCompletionResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: JoinPartyCallback_t
// ------------------------------------------------------------

struct _PendingCall_JoinPartyCallback_t {
  CCallResult<_PendingCall_JoinPartyCallback_t, JoinPartyCallback_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_JoinPartyCallback_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_JoinPartyCallback_t::OnComplete);
  }

  ~_PendingCall_JoinPartyCallback_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(JoinPartyCallback_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulBeaconID));
      PyDict_SetItemString(dict, "beacon_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_SteamIDBeaconOwner).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_beacon_owner", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchConnectString);
      PyDict_SetItemString(dict, "rgch_connect_string", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_JoinPartyCallback_t*> _pending_JoinPartyCallback_t;

void _steam_async_call_JoinPartyCallback_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_JoinPartyCallback_t(call, callback);
  _pending_JoinPartyCallback_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LeaderboardFindResult_t
// ------------------------------------------------------------

struct _PendingCall_LeaderboardFindResult_t {
  CCallResult<_PendingCall_LeaderboardFindResult_t, LeaderboardFindResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LeaderboardFindResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LeaderboardFindResult_t::OnComplete);
  }

  ~_PendingCall_LeaderboardFindResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LeaderboardFindResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hSteamLeaderboard));
      PyDict_SetItemString(dict, "steam_leaderboard", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_bLeaderboardFound));
      PyDict_SetItemString(dict, "leaderboard_found", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LeaderboardFindResult_t*> _pending_LeaderboardFindResult_t;

void _steam_async_call_LeaderboardFindResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LeaderboardFindResult_t(call, callback);
  _pending_LeaderboardFindResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LeaderboardScoreUploaded_t
// ------------------------------------------------------------

struct _PendingCall_LeaderboardScoreUploaded_t {
  CCallResult<_PendingCall_LeaderboardScoreUploaded_t, LeaderboardScoreUploaded_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LeaderboardScoreUploaded_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LeaderboardScoreUploaded_t::OnComplete);
  }

  ~_PendingCall_LeaderboardScoreUploaded_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LeaderboardScoreUploaded_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_bSuccess));
      PyDict_SetItemString(dict, "success", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hSteamLeaderboard));
      PyDict_SetItemString(dict, "steam_leaderboard", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nScore));
      PyDict_SetItemString(dict, "score", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_bScoreChanged));
      PyDict_SetItemString(dict, "score_changed", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nGlobalRankNew));
      PyDict_SetItemString(dict, "global_rank_new", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nGlobalRankPrevious));
      PyDict_SetItemString(dict, "global_rank_previous", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LeaderboardScoreUploaded_t*> _pending_LeaderboardScoreUploaded_t;

void _steam_async_call_LeaderboardScoreUploaded_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LeaderboardScoreUploaded_t(call, callback);
  _pending_LeaderboardScoreUploaded_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LeaderboardScoresDownloaded_t
// ------------------------------------------------------------

struct _PendingCall_LeaderboardScoresDownloaded_t {
  CCallResult<_PendingCall_LeaderboardScoresDownloaded_t, LeaderboardScoresDownloaded_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LeaderboardScoresDownloaded_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LeaderboardScoresDownloaded_t::OnComplete);
  }

  ~_PendingCall_LeaderboardScoresDownloaded_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LeaderboardScoresDownloaded_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hSteamLeaderboard));
      PyDict_SetItemString(dict, "steam_leaderboard", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hSteamLeaderboardEntries));
      PyDict_SetItemString(dict, "steam_leaderboard_entries", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cEntryCount));
      PyDict_SetItemString(dict, "entry_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LeaderboardScoresDownloaded_t*> _pending_LeaderboardScoresDownloaded_t;

void _steam_async_call_LeaderboardScoresDownloaded_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LeaderboardScoresDownloaded_t(call, callback);
  _pending_LeaderboardScoresDownloaded_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LeaderboardUGCSet_t
// ------------------------------------------------------------

struct _PendingCall_LeaderboardUGCSet_t {
  CCallResult<_PendingCall_LeaderboardUGCSet_t, LeaderboardUGCSet_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LeaderboardUGCSet_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LeaderboardUGCSet_t::OnComplete);
  }

  ~_PendingCall_LeaderboardUGCSet_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LeaderboardUGCSet_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hSteamLeaderboard));
      PyDict_SetItemString(dict, "steam_leaderboard", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LeaderboardUGCSet_t*> _pending_LeaderboardUGCSet_t;

void _steam_async_call_LeaderboardUGCSet_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LeaderboardUGCSet_t(call, callback);
  _pending_LeaderboardUGCSet_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LobbyCreated_t
// ------------------------------------------------------------

struct _PendingCall_LobbyCreated_t {
  CCallResult<_PendingCall_LobbyCreated_t, LobbyCreated_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LobbyCreated_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LobbyCreated_t::OnComplete);
  }

  ~_PendingCall_LobbyCreated_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LobbyCreated_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulSteamIDLobby));
      PyDict_SetItemString(dict, "steam_id_lobby", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LobbyCreated_t*> _pending_LobbyCreated_t;

void _steam_async_call_LobbyCreated_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LobbyCreated_t(call, callback);
  _pending_LobbyCreated_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LobbyEnter_t
// ------------------------------------------------------------

struct _PendingCall_LobbyEnter_t {
  CCallResult<_PendingCall_LobbyEnter_t, LobbyEnter_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LobbyEnter_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LobbyEnter_t::OnComplete);
  }

  ~_PendingCall_LobbyEnter_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LobbyEnter_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulSteamIDLobby));
      PyDict_SetItemString(dict, "steam_id_lobby", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_rgfChatPermissions));
      PyDict_SetItemString(dict, "chat_permissions", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bLocked));
      PyDict_SetItemString(dict, "locked", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_EChatRoomEnterResponse));
      PyDict_SetItemString(dict, "e_chat_room_enter_response", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LobbyEnter_t*> _pending_LobbyEnter_t;

void _steam_async_call_LobbyEnter_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LobbyEnter_t(call, callback);
  _pending_LobbyEnter_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: LobbyMatchList_t
// ------------------------------------------------------------

struct _PendingCall_LobbyMatchList_t {
  CCallResult<_PendingCall_LobbyMatchList_t, LobbyMatchList_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_LobbyMatchList_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_LobbyMatchList_t::OnComplete);
  }

  ~_PendingCall_LobbyMatchList_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(LobbyMatchList_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nLobbiesMatching));
      PyDict_SetItemString(dict, "lobbies_matching", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_LobbyMatchList_t*> _pending_LobbyMatchList_t;

void _steam_async_call_LobbyMatchList_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_LobbyMatchList_t(call, callback);
  _pending_LobbyMatchList_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: MarketEligibilityResponse_t
// ------------------------------------------------------------

struct _PendingCall_MarketEligibilityResponse_t {
  CCallResult<_PendingCall_MarketEligibilityResponse_t, MarketEligibilityResponse_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_MarketEligibilityResponse_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_MarketEligibilityResponse_t::OnComplete);
  }

  ~_PendingCall_MarketEligibilityResponse_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(MarketEligibilityResponse_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyBool_FromLong((long)(pResult->m_bAllowed));
      PyDict_SetItemString(dict, "allowed", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eNotAllowedReason));
      PyDict_SetItemString(dict, "not_allowed_reason", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_rtAllowedAtTime));
      PyDict_SetItemString(dict, "rt_allowed_at_time", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cdaySteamGuardRequiredDays));
      PyDict_SetItemString(dict, "cday_steam_guard_required_days", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cdayNewDeviceCooldown));
      PyDict_SetItemString(dict, "cday_new_device_cooldown", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_MarketEligibilityResponse_t*> _pending_MarketEligibilityResponse_t;

void _steam_async_call_MarketEligibilityResponse_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_MarketEligibilityResponse_t(call, callback);
  _pending_MarketEligibilityResponse_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: NumberOfCurrentPlayers_t
// ------------------------------------------------------------

struct _PendingCall_NumberOfCurrentPlayers_t {
  CCallResult<_PendingCall_NumberOfCurrentPlayers_t, NumberOfCurrentPlayers_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_NumberOfCurrentPlayers_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_NumberOfCurrentPlayers_t::OnComplete);
  }

  ~_PendingCall_NumberOfCurrentPlayers_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(NumberOfCurrentPlayers_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_bSuccess));
      PyDict_SetItemString(dict, "success", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_cPlayers));
      PyDict_SetItemString(dict, "players", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_NumberOfCurrentPlayers_t*> _pending_NumberOfCurrentPlayers_t;

void _steam_async_call_NumberOfCurrentPlayers_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_NumberOfCurrentPlayers_t(call, callback);
  _pending_NumberOfCurrentPlayers_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageDeletePublishedFileResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageDeletePublishedFileResult_t {
  CCallResult<_PendingCall_RemoteStorageDeletePublishedFileResult_t, RemoteStorageDeletePublishedFileResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageDeletePublishedFileResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageDeletePublishedFileResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageDeletePublishedFileResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageDeletePublishedFileResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageDeletePublishedFileResult_t*> _pending_RemoteStorageDeletePublishedFileResult_t;

void _steam_async_call_RemoteStorageDeletePublishedFileResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageDeletePublishedFileResult_t(call, callback);
  _pending_RemoteStorageDeletePublishedFileResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageDownloadUGCResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageDownloadUGCResult_t {
  CCallResult<_PendingCall_RemoteStorageDownloadUGCResult_t, RemoteStorageDownloadUGCResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageDownloadUGCResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageDownloadUGCResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageDownloadUGCResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageDownloadUGCResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hFile));
      PyDict_SetItemString(dict, "file", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nAppID));
      PyDict_SetItemString(dict, "app_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nSizeInBytes));
      PyDict_SetItemString(dict, "size_in_bytes", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_pchFileName);
      PyDict_SetItemString(dict, "file_name", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulSteamIDOwner));
      PyDict_SetItemString(dict, "steam_id_owner", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageDownloadUGCResult_t*> _pending_RemoteStorageDownloadUGCResult_t;

void _steam_async_call_RemoteStorageDownloadUGCResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageDownloadUGCResult_t(call, callback);
  _pending_RemoteStorageDownloadUGCResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageEnumeratePublishedFilesByUserActionResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t {
  CCallResult<_PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t, RemoteStorageEnumeratePublishedFilesByUserActionResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageEnumeratePublishedFilesByUserActionResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eAction));
      PyDict_SetItemString(dict, "action", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nResultsReturned));
      PyDict_SetItemString(dict, "results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nTotalResultCount));
      PyDict_SetItemString(dict, "total_result_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t*> _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t;

void _steam_async_call_RemoteStorageEnumeratePublishedFilesByUserActionResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageEnumeratePublishedFilesByUserActionResult_t(call, callback);
  _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageEnumerateUserPublishedFilesResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t {
  CCallResult<_PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t, RemoteStorageEnumerateUserPublishedFilesResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageEnumerateUserPublishedFilesResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nResultsReturned));
      PyDict_SetItemString(dict, "results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nTotalResultCount));
      PyDict_SetItemString(dict, "total_result_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t*> _pending_RemoteStorageEnumerateUserPublishedFilesResult_t;

void _steam_async_call_RemoteStorageEnumerateUserPublishedFilesResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageEnumerateUserPublishedFilesResult_t(call, callback);
  _pending_RemoteStorageEnumerateUserPublishedFilesResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageEnumerateUserSubscribedFilesResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t {
  CCallResult<_PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t, RemoteStorageEnumerateUserSubscribedFilesResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageEnumerateUserSubscribedFilesResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nResultsReturned));
      PyDict_SetItemString(dict, "results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nTotalResultCount));
      PyDict_SetItemString(dict, "total_result_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t*> _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t;

void _steam_async_call_RemoteStorageEnumerateUserSubscribedFilesResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageEnumerateUserSubscribedFilesResult_t(call, callback);
  _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageEnumerateWorkshopFilesResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t {
  CCallResult<_PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t, RemoteStorageEnumerateWorkshopFilesResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageEnumerateWorkshopFilesResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nResultsReturned));
      PyDict_SetItemString(dict, "results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nTotalResultCount));
      PyDict_SetItemString(dict, "total_result_count", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nAppId));
      PyDict_SetItemString(dict, "app_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unStartIndex));
      PyDict_SetItemString(dict, "start_index", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t*> _pending_RemoteStorageEnumerateWorkshopFilesResult_t;

void _steam_async_call_RemoteStorageEnumerateWorkshopFilesResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageEnumerateWorkshopFilesResult_t(call, callback);
  _pending_RemoteStorageEnumerateWorkshopFilesResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageFileReadAsyncComplete_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageFileReadAsyncComplete_t {
  CCallResult<_PendingCall_RemoteStorageFileReadAsyncComplete_t, RemoteStorageFileReadAsyncComplete_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageFileReadAsyncComplete_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageFileReadAsyncComplete_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageFileReadAsyncComplete_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageFileReadAsyncComplete_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hFileReadAsync));
      PyDict_SetItemString(dict, "file_read_async", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nOffset));
      PyDict_SetItemString(dict, "offset", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_cubRead));
      PyDict_SetItemString(dict, "read", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageFileReadAsyncComplete_t*> _pending_RemoteStorageFileReadAsyncComplete_t;

void _steam_async_call_RemoteStorageFileReadAsyncComplete_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageFileReadAsyncComplete_t(call, callback);
  _pending_RemoteStorageFileReadAsyncComplete_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageFileShareResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageFileShareResult_t {
  CCallResult<_PendingCall_RemoteStorageFileShareResult_t, RemoteStorageFileShareResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageFileShareResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageFileShareResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageFileShareResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageFileShareResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hFile));
      PyDict_SetItemString(dict, "file", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchFilename);
      PyDict_SetItemString(dict, "rgch_filename", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageFileShareResult_t*> _pending_RemoteStorageFileShareResult_t;

void _steam_async_call_RemoteStorageFileShareResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageFileShareResult_t(call, callback);
  _pending_RemoteStorageFileShareResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageFileWriteAsyncComplete_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageFileWriteAsyncComplete_t {
  CCallResult<_PendingCall_RemoteStorageFileWriteAsyncComplete_t, RemoteStorageFileWriteAsyncComplete_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageFileWriteAsyncComplete_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageFileWriteAsyncComplete_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageFileWriteAsyncComplete_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageFileWriteAsyncComplete_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageFileWriteAsyncComplete_t*> _pending_RemoteStorageFileWriteAsyncComplete_t;

void _steam_async_call_RemoteStorageFileWriteAsyncComplete_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageFileWriteAsyncComplete_t(call, callback);
  _pending_RemoteStorageFileWriteAsyncComplete_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageGetPublishedFileDetailsResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageGetPublishedFileDetailsResult_t {
  CCallResult<_PendingCall_RemoteStorageGetPublishedFileDetailsResult_t, RemoteStorageGetPublishedFileDetailsResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageGetPublishedFileDetailsResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageGetPublishedFileDetailsResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageGetPublishedFileDetailsResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageGetPublishedFileDetailsResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nCreatorAppID));
      PyDict_SetItemString(dict, "creator_app_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nConsumerAppID));
      PyDict_SetItemString(dict, "consumer_app_id", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchTitle);
      PyDict_SetItemString(dict, "rgch_title", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchDescription);
      PyDict_SetItemString(dict, "rgch_description", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hFile));
      PyDict_SetItemString(dict, "file", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_hPreviewFile));
      PyDict_SetItemString(dict, "preview_file", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulSteamIDOwner));
      PyDict_SetItemString(dict, "steam_id_owner", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_rtimeCreated));
      PyDict_SetItemString(dict, "rtime_created", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_rtimeUpdated));
      PyDict_SetItemString(dict, "rtime_updated", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eVisibility));
      PyDict_SetItemString(dict, "visibility", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bBanned));
      PyDict_SetItemString(dict, "banned", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchTags);
      PyDict_SetItemString(dict, "rgch_tags", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bTagsTruncated));
      PyDict_SetItemString(dict, "tags_truncated", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_pchFileName);
      PyDict_SetItemString(dict, "file_name", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nFileSize));
      PyDict_SetItemString(dict, "file_size", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nPreviewFileSize));
      PyDict_SetItemString(dict, "preview_file_size", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchURL);
      PyDict_SetItemString(dict, "rgch_url", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eFileType));
      PyDict_SetItemString(dict, "file_type", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bAcceptedForUse));
      PyDict_SetItemString(dict, "accepted_for_use", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageGetPublishedFileDetailsResult_t*> _pending_RemoteStorageGetPublishedFileDetailsResult_t;

void _steam_async_call_RemoteStorageGetPublishedFileDetailsResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageGetPublishedFileDetailsResult_t(call, callback);
  _pending_RemoteStorageGetPublishedFileDetailsResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageGetPublishedItemVoteDetailsResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t {
  CCallResult<_PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t, RemoteStorageGetPublishedItemVoteDetailsResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageGetPublishedItemVoteDetailsResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_unPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nVotesFor));
      PyDict_SetItemString(dict, "votes_for", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nVotesAgainst));
      PyDict_SetItemString(dict, "votes_against", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_nReports));
      PyDict_SetItemString(dict, "reports", val);
      Py_DECREF(val);
      val = PyFloat_FromDouble((double)(pResult->m_fScore));
      PyDict_SetItemString(dict, "score", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t*> _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t;

void _steam_async_call_RemoteStorageGetPublishedItemVoteDetailsResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageGetPublishedItemVoteDetailsResult_t(call, callback);
  _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStoragePublishFileProgress_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStoragePublishFileProgress_t {
  CCallResult<_PendingCall_RemoteStoragePublishFileProgress_t, RemoteStoragePublishFileProgress_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStoragePublishFileProgress_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStoragePublishFileProgress_t::OnComplete);
  }

  ~_PendingCall_RemoteStoragePublishFileProgress_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStoragePublishFileProgress_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyFloat_FromDouble((double)(pResult->m_dPercentFile));
      PyDict_SetItemString(dict, "d_percent_file", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bPreview));
      PyDict_SetItemString(dict, "preview", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStoragePublishFileProgress_t*> _pending_RemoteStoragePublishFileProgress_t;

void _steam_async_call_RemoteStoragePublishFileProgress_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStoragePublishFileProgress_t(call, callback);
  _pending_RemoteStoragePublishFileProgress_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageSetUserPublishedFileActionResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageSetUserPublishedFileActionResult_t {
  CCallResult<_PendingCall_RemoteStorageSetUserPublishedFileActionResult_t, RemoteStorageSetUserPublishedFileActionResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageSetUserPublishedFileActionResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageSetUserPublishedFileActionResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageSetUserPublishedFileActionResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageSetUserPublishedFileActionResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eAction));
      PyDict_SetItemString(dict, "action", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageSetUserPublishedFileActionResult_t*> _pending_RemoteStorageSetUserPublishedFileActionResult_t;

void _steam_async_call_RemoteStorageSetUserPublishedFileActionResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageSetUserPublishedFileActionResult_t(call, callback);
  _pending_RemoteStorageSetUserPublishedFileActionResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageSubscribePublishedFileResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageSubscribePublishedFileResult_t {
  CCallResult<_PendingCall_RemoteStorageSubscribePublishedFileResult_t, RemoteStorageSubscribePublishedFileResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageSubscribePublishedFileResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageSubscribePublishedFileResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageSubscribePublishedFileResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageSubscribePublishedFileResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageSubscribePublishedFileResult_t*> _pending_RemoteStorageSubscribePublishedFileResult_t;

void _steam_async_call_RemoteStorageSubscribePublishedFileResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageSubscribePublishedFileResult_t(call, callback);
  _pending_RemoteStorageSubscribePublishedFileResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageUnsubscribePublishedFileResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageUnsubscribePublishedFileResult_t {
  CCallResult<_PendingCall_RemoteStorageUnsubscribePublishedFileResult_t, RemoteStorageUnsubscribePublishedFileResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageUnsubscribePublishedFileResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageUnsubscribePublishedFileResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageUnsubscribePublishedFileResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageUnsubscribePublishedFileResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageUnsubscribePublishedFileResult_t*> _pending_RemoteStorageUnsubscribePublishedFileResult_t;

void _steam_async_call_RemoteStorageUnsubscribePublishedFileResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageUnsubscribePublishedFileResult_t(call, callback);
  _pending_RemoteStorageUnsubscribePublishedFileResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageUpdatePublishedFileResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageUpdatePublishedFileResult_t {
  CCallResult<_PendingCall_RemoteStorageUpdatePublishedFileResult_t, RemoteStorageUpdatePublishedFileResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageUpdatePublishedFileResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageUpdatePublishedFileResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageUpdatePublishedFileResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageUpdatePublishedFileResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bUserNeedsToAcceptWorkshopLegalAgreement));
      PyDict_SetItemString(dict, "user_needs_to_accept_workshop_legal_agreement", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageUpdatePublishedFileResult_t*> _pending_RemoteStorageUpdatePublishedFileResult_t;

void _steam_async_call_RemoteStorageUpdatePublishedFileResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageUpdatePublishedFileResult_t(call, callback);
  _pending_RemoteStorageUpdatePublishedFileResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoteStorageUpdateUserPublishedItemVoteResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t {
  CCallResult<_PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t, RemoteStorageUpdateUserPublishedItemVoteResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t::OnComplete);
  }

  ~_PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoteStorageUpdateUserPublishedItemVoteResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t*> _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t;

void _steam_async_call_RemoteStorageUpdateUserPublishedItemVoteResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoteStorageUpdateUserPublishedItemVoteResult_t(call, callback);
  _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoveAppDependencyResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoveAppDependencyResult_t {
  CCallResult<_PendingCall_RemoveAppDependencyResult_t, RemoveAppDependencyResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoveAppDependencyResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoveAppDependencyResult_t::OnComplete);
  }

  ~_PendingCall_RemoveAppDependencyResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoveAppDependencyResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nAppID));
      PyDict_SetItemString(dict, "app_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoveAppDependencyResult_t*> _pending_RemoveAppDependencyResult_t;

void _steam_async_call_RemoveAppDependencyResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoveAppDependencyResult_t(call, callback);
  _pending_RemoveAppDependencyResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: RemoveUGCDependencyResult_t
// ------------------------------------------------------------

struct _PendingCall_RemoveUGCDependencyResult_t {
  CCallResult<_PendingCall_RemoveUGCDependencyResult_t, RemoveUGCDependencyResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_RemoveUGCDependencyResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_RemoveUGCDependencyResult_t::OnComplete);
  }

  ~_PendingCall_RemoveUGCDependencyResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(RemoveUGCDependencyResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nChildPublishedFileId));
      PyDict_SetItemString(dict, "child_published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_RemoveUGCDependencyResult_t*> _pending_RemoveUGCDependencyResult_t;

void _steam_async_call_RemoveUGCDependencyResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_RemoveUGCDependencyResult_t(call, callback);
  _pending_RemoveUGCDependencyResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SetUserItemVoteResult_t
// ------------------------------------------------------------

struct _PendingCall_SetUserItemVoteResult_t {
  CCallResult<_PendingCall_SetUserItemVoteResult_t, SetUserItemVoteResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SetUserItemVoteResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SetUserItemVoteResult_t::OnComplete);
  }

  ~_PendingCall_SetUserItemVoteResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SetUserItemVoteResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bVoteUp));
      PyDict_SetItemString(dict, "vote_up", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SetUserItemVoteResult_t*> _pending_SetUserItemVoteResult_t;

void _steam_async_call_SetUserItemVoteResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SetUserItemVoteResult_t(call, callback);
  _pending_SetUserItemVoteResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: StartPlaytimeTrackingResult_t
// ------------------------------------------------------------

struct _PendingCall_StartPlaytimeTrackingResult_t {
  CCallResult<_PendingCall_StartPlaytimeTrackingResult_t, StartPlaytimeTrackingResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_StartPlaytimeTrackingResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_StartPlaytimeTrackingResult_t::OnComplete);
  }

  ~_PendingCall_StartPlaytimeTrackingResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(StartPlaytimeTrackingResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_StartPlaytimeTrackingResult_t*> _pending_StartPlaytimeTrackingResult_t;

void _steam_async_call_StartPlaytimeTrackingResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_StartPlaytimeTrackingResult_t(call, callback);
  _pending_StartPlaytimeTrackingResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamInventoryEligiblePromoItemDefIDs_t
// ------------------------------------------------------------

struct _PendingCall_SteamInventoryEligiblePromoItemDefIDs_t {
  CCallResult<_PendingCall_SteamInventoryEligiblePromoItemDefIDs_t, SteamInventoryEligiblePromoItemDefIDs_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamInventoryEligiblePromoItemDefIDs_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamInventoryEligiblePromoItemDefIDs_t::OnComplete);
  }

  ~_PendingCall_SteamInventoryEligiblePromoItemDefIDs_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamInventoryEligiblePromoItemDefIDs_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_result));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamID).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_numEligiblePromoItemDefs));
      PyDict_SetItemString(dict, "num_eligible_promo_item_defs", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bCachedData));
      PyDict_SetItemString(dict, "cached_data", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamInventoryEligiblePromoItemDefIDs_t*> _pending_SteamInventoryEligiblePromoItemDefIDs_t;

void _steam_async_call_SteamInventoryEligiblePromoItemDefIDs_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamInventoryEligiblePromoItemDefIDs_t(call, callback);
  _pending_SteamInventoryEligiblePromoItemDefIDs_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamInventoryRequestPricesResult_t
// ------------------------------------------------------------

struct _PendingCall_SteamInventoryRequestPricesResult_t {
  CCallResult<_PendingCall_SteamInventoryRequestPricesResult_t, SteamInventoryRequestPricesResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamInventoryRequestPricesResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamInventoryRequestPricesResult_t::OnComplete);
  }

  ~_PendingCall_SteamInventoryRequestPricesResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamInventoryRequestPricesResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_result));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchCurrency);
      PyDict_SetItemString(dict, "rgch_currency", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamInventoryRequestPricesResult_t*> _pending_SteamInventoryRequestPricesResult_t;

void _steam_async_call_SteamInventoryRequestPricesResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamInventoryRequestPricesResult_t(call, callback);
  _pending_SteamInventoryRequestPricesResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamInventoryStartPurchaseResult_t
// ------------------------------------------------------------

struct _PendingCall_SteamInventoryStartPurchaseResult_t {
  CCallResult<_PendingCall_SteamInventoryStartPurchaseResult_t, SteamInventoryStartPurchaseResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamInventoryStartPurchaseResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamInventoryStartPurchaseResult_t::OnComplete);
  }

  ~_PendingCall_SteamInventoryStartPurchaseResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamInventoryStartPurchaseResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_result));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulOrderID));
      PyDict_SetItemString(dict, "order_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulTransID));
      PyDict_SetItemString(dict, "trans_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamInventoryStartPurchaseResult_t*> _pending_SteamInventoryStartPurchaseResult_t;

void _steam_async_call_SteamInventoryStartPurchaseResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamInventoryStartPurchaseResult_t(call, callback);
  _pending_SteamInventoryStartPurchaseResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamTimelineEventRecordingExists_t
// ------------------------------------------------------------

struct _PendingCall_SteamTimelineEventRecordingExists_t {
  CCallResult<_PendingCall_SteamTimelineEventRecordingExists_t, SteamTimelineEventRecordingExists_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamTimelineEventRecordingExists_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamTimelineEventRecordingExists_t::OnComplete);
  }

  ~_PendingCall_SteamTimelineEventRecordingExists_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamTimelineEventRecordingExists_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulEventID));
      PyDict_SetItemString(dict, "event_id", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bRecordingExists));
      PyDict_SetItemString(dict, "recording_exists", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamTimelineEventRecordingExists_t*> _pending_SteamTimelineEventRecordingExists_t;

void _steam_async_call_SteamTimelineEventRecordingExists_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamTimelineEventRecordingExists_t(call, callback);
  _pending_SteamTimelineEventRecordingExists_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamTimelineGamePhaseRecordingExists_t
// ------------------------------------------------------------

struct _PendingCall_SteamTimelineGamePhaseRecordingExists_t {
  CCallResult<_PendingCall_SteamTimelineGamePhaseRecordingExists_t, SteamTimelineGamePhaseRecordingExists_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamTimelineGamePhaseRecordingExists_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamTimelineGamePhaseRecordingExists_t::OnComplete);
  }

  ~_PendingCall_SteamTimelineGamePhaseRecordingExists_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamTimelineGamePhaseRecordingExists_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyUnicode_FromString(pResult->m_rgchPhaseID);
      PyDict_SetItemString(dict, "rgch_phase_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulRecordingMS));
      PyDict_SetItemString(dict, "recording_ms", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_ulLongestClipMS));
      PyDict_SetItemString(dict, "longest_clip_ms", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unClipCount));
      PyDict_SetItemString(dict, "clip_count", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unScreenshotCount));
      PyDict_SetItemString(dict, "screenshot_count", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamTimelineGamePhaseRecordingExists_t*> _pending_SteamTimelineGamePhaseRecordingExists_t;

void _steam_async_call_SteamTimelineGamePhaseRecordingExists_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamTimelineGamePhaseRecordingExists_t(call, callback);
  _pending_SteamTimelineGamePhaseRecordingExists_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamUGCQueryCompleted_t
// ------------------------------------------------------------

struct _PendingCall_SteamUGCQueryCompleted_t {
  CCallResult<_PendingCall_SteamUGCQueryCompleted_t, SteamUGCQueryCompleted_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamUGCQueryCompleted_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamUGCQueryCompleted_t::OnComplete);
  }

  ~_PendingCall_SteamUGCQueryCompleted_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamUGCQueryCompleted_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_handle));
      PyDict_SetItemString(dict, "handle", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unNumResultsReturned));
      PyDict_SetItemString(dict, "num_results_returned", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unTotalMatchingResults));
      PyDict_SetItemString(dict, "total_matching_results", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bCachedData));
      PyDict_SetItemString(dict, "cached_data", val);
      Py_DECREF(val);
      val = PyUnicode_FromString(pResult->m_rgchNextCursor);
      PyDict_SetItemString(dict, "rgch_next_cursor", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamUGCQueryCompleted_t*> _pending_SteamUGCQueryCompleted_t;

void _steam_async_call_SteamUGCQueryCompleted_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamUGCQueryCompleted_t(call, callback);
  _pending_SteamUGCQueryCompleted_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SteamUGCRequestUGCDetailsResult_t
// ------------------------------------------------------------

struct _PendingCall_SteamUGCRequestUGCDetailsResult_t {
  CCallResult<_PendingCall_SteamUGCRequestUGCDetailsResult_t, SteamUGCRequestUGCDetailsResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SteamUGCRequestUGCDetailsResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SteamUGCRequestUGCDetailsResult_t::OnComplete);
  }

  ~_PendingCall_SteamUGCRequestUGCDetailsResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SteamUGCRequestUGCDetailsResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyBool_FromLong((long)(pResult->m_bCachedData));
      PyDict_SetItemString(dict, "cached_data", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SteamUGCRequestUGCDetailsResult_t*> _pending_SteamUGCRequestUGCDetailsResult_t;

void _steam_async_call_SteamUGCRequestUGCDetailsResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SteamUGCRequestUGCDetailsResult_t(call, callback);
  _pending_SteamUGCRequestUGCDetailsResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: StopPlaytimeTrackingResult_t
// ------------------------------------------------------------

struct _PendingCall_StopPlaytimeTrackingResult_t {
  CCallResult<_PendingCall_StopPlaytimeTrackingResult_t, StopPlaytimeTrackingResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_StopPlaytimeTrackingResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_StopPlaytimeTrackingResult_t::OnComplete);
  }

  ~_PendingCall_StopPlaytimeTrackingResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(StopPlaytimeTrackingResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_StopPlaytimeTrackingResult_t*> _pending_StopPlaytimeTrackingResult_t;

void _steam_async_call_StopPlaytimeTrackingResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_StopPlaytimeTrackingResult_t(call, callback);
  _pending_StopPlaytimeTrackingResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: StoreAuthURLResponse_t
// ------------------------------------------------------------

struct _PendingCall_StoreAuthURLResponse_t {
  CCallResult<_PendingCall_StoreAuthURLResponse_t, StoreAuthURLResponse_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_StoreAuthURLResponse_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_StoreAuthURLResponse_t::OnComplete);
  }

  ~_PendingCall_StoreAuthURLResponse_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(StoreAuthURLResponse_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyUnicode_FromString(pResult->m_szURL);
      PyDict_SetItemString(dict, "url", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_StoreAuthURLResponse_t*> _pending_StoreAuthURLResponse_t;

void _steam_async_call_StoreAuthURLResponse_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_StoreAuthURLResponse_t(call, callback);
  _pending_StoreAuthURLResponse_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: SubmitItemUpdateResult_t
// ------------------------------------------------------------

struct _PendingCall_SubmitItemUpdateResult_t {
  CCallResult<_PendingCall_SubmitItemUpdateResult_t, SubmitItemUpdateResult_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_SubmitItemUpdateResult_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_SubmitItemUpdateResult_t::OnComplete);
  }

  ~_PendingCall_SubmitItemUpdateResult_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(SubmitItemUpdateResult_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bUserNeedsToAcceptWorkshopLegalAgreement));
      PyDict_SetItemString(dict, "user_needs_to_accept_workshop_legal_agreement", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_SubmitItemUpdateResult_t*> _pending_SubmitItemUpdateResult_t;

void _steam_async_call_SubmitItemUpdateResult_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_SubmitItemUpdateResult_t(call, callback);
  _pending_SubmitItemUpdateResult_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: UserFavoriteItemsListChanged_t
// ------------------------------------------------------------

struct _PendingCall_UserFavoriteItemsListChanged_t {
  CCallResult<_PendingCall_UserFavoriteItemsListChanged_t, UserFavoriteItemsListChanged_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_UserFavoriteItemsListChanged_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_UserFavoriteItemsListChanged_t::OnComplete);
  }

  ~_PendingCall_UserFavoriteItemsListChanged_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(UserFavoriteItemsListChanged_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nPublishedFileId));
      PyDict_SetItemString(dict, "published_file_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bWasAddRequest));
      PyDict_SetItemString(dict, "was_add_request", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_UserFavoriteItemsListChanged_t*> _pending_UserFavoriteItemsListChanged_t;

void _steam_async_call_UserFavoriteItemsListChanged_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_UserFavoriteItemsListChanged_t(call, callback);
  _pending_UserFavoriteItemsListChanged_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: UserStatsReceived_t
// ------------------------------------------------------------

struct _PendingCall_UserStatsReceived_t {
  CCallResult<_PendingCall_UserStatsReceived_t, UserStatsReceived_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_UserStatsReceived_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_UserStatsReceived_t::OnComplete);
  }

  ~_PendingCall_UserStatsReceived_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(UserStatsReceived_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromUnsignedLongLong((unsigned long long)(pResult->m_nGameID));
      PyDict_SetItemString(dict, "game_id", val);
      Py_DECREF(val);
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLongLong((pResult->m_steamIDUser).ConvertToUint64());
      PyDict_SetItemString(dict, "steam_id_user", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_UserStatsReceived_t*> _pending_UserStatsReceived_t;

void _steam_async_call_UserStatsReceived_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_UserStatsReceived_t(call, callback);
  _pending_UserStatsReceived_t.push_back(h);
}

// ------------------------------------------------------------
// Async result handler: WorkshopEULAStatus_t
// ------------------------------------------------------------

struct _PendingCall_WorkshopEULAStatus_t {
  CCallResult<_PendingCall_WorkshopEULAStatus_t, WorkshopEULAStatus_t> call_result;
  PyObject *py_callback;
  bool completed;

  _PendingCall_WorkshopEULAStatus_t(SteamAPICall_t call, PyObject *cb)
    : py_callback(cb), completed(false) {
    Py_XINCREF(py_callback);
    call_result.Set(call, this, &_PendingCall_WorkshopEULAStatus_t::OnComplete);
  }

  ~_PendingCall_WorkshopEULAStatus_t() {
    Py_XDECREF(py_callback);
  }

  void OnComplete(WorkshopEULAStatus_t *pResult, bool bIOFailure) {
    if (py_callback && py_callback != Py_None && PyCallable_Check(py_callback)) {
      PyObject *dict = PyDict_New();
      PyObject *val;
      val = PyLong_FromLong((long)(pResult->m_eResult));
      PyDict_SetItemString(dict, "result", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_nAppID));
      PyDict_SetItemString(dict, "app_id", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_unVersion));
      PyDict_SetItemString(dict, "version", val);
      Py_DECREF(val);
      val = PyLong_FromUnsignedLong((unsigned long)(pResult->m_rtAction));
      PyDict_SetItemString(dict, "rt_action", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bAccepted));
      PyDict_SetItemString(dict, "accepted", val);
      Py_DECREF(val);
      val = PyBool_FromLong((long)(pResult->m_bNeedsAction));
      PyDict_SetItemString(dict, "needs_action", val);
      Py_DECREF(val);
      val = bIOFailure ? Py_True : Py_False;
      Py_INCREF(val);
      PyDict_SetItemString(dict, "io_failure", val);
      Py_DECREF(val);
      PyObject *ret = PyObject_CallFunctionObjArgs(py_callback, dict, NULL);
      if (!ret) PyErr_Print();
      Py_XDECREF(ret);
      Py_DECREF(dict);
    }
    completed = true;
  }
};

static std::vector<_PendingCall_WorkshopEULAStatus_t*> _pending_WorkshopEULAStatus_t;

void _steam_async_call_WorkshopEULAStatus_t(SteamAPICall_t call, PyObject *callback) {
  auto *h = new _PendingCall_WorkshopEULAStatus_t(call, callback);
  _pending_WorkshopEULAStatus_t.push_back(h);
}

static void _cleanup_completed_calls() {
  for (auto it = _pending_AddAppDependencyResult_t.begin(); it != _pending_AddAppDependencyResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_AddAppDependencyResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_AddUGCDependencyResult_t.begin(); it != _pending_AddUGCDependencyResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_AddUGCDependencyResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_AssociateWithClanResult_t.begin(); it != _pending_AssociateWithClanResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_AssociateWithClanResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_ChangeNumOpenSlotsCallback_t.begin(); it != _pending_ChangeNumOpenSlotsCallback_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_ChangeNumOpenSlotsCallback_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_CheckFileSignature_t.begin(); it != _pending_CheckFileSignature_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_CheckFileSignature_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_ClanOfficerListResponse_t.begin(); it != _pending_ClanOfficerListResponse_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_ClanOfficerListResponse_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_ComputeNewPlayerCompatibilityResult_t.begin(); it != _pending_ComputeNewPlayerCompatibilityResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_ComputeNewPlayerCompatibilityResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_CreateBeaconCallback_t.begin(); it != _pending_CreateBeaconCallback_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_CreateBeaconCallback_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_CreateItemResult_t.begin(); it != _pending_CreateItemResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_CreateItemResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_DeleteItemResult_t.begin(); it != _pending_DeleteItemResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_DeleteItemResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_DownloadClanActivityCountsResult_t.begin(); it != _pending_DownloadClanActivityCountsResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_DownloadClanActivityCountsResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_DurationControl_t.begin(); it != _pending_DurationControl_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_DurationControl_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_EncryptedAppTicketResponse_t.begin(); it != _pending_EncryptedAppTicketResponse_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_EncryptedAppTicketResponse_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_EquippedProfileItems_t.begin(); it != _pending_EquippedProfileItems_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_EquippedProfileItems_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_FileDetailsResult_t.begin(); it != _pending_FileDetailsResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_FileDetailsResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_FriendsEnumerateFollowingList_t.begin(); it != _pending_FriendsEnumerateFollowingList_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_FriendsEnumerateFollowingList_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_FriendsGetFollowerCount_t.begin(); it != _pending_FriendsGetFollowerCount_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_FriendsGetFollowerCount_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_FriendsIsFollowing_t.begin(); it != _pending_FriendsIsFollowing_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_FriendsIsFollowing_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GSReputation_t.begin(); it != _pending_GSReputation_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GSReputation_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GSStatsReceived_t.begin(); it != _pending_GSStatsReceived_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GSStatsReceived_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GSStatsStored_t.begin(); it != _pending_GSStatsStored_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GSStatsStored_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GetAppDependenciesResult_t.begin(); it != _pending_GetAppDependenciesResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GetAppDependenciesResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GetUserItemVoteResult_t.begin(); it != _pending_GetUserItemVoteResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GetUserItemVoteResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GlobalAchievementPercentagesReady_t.begin(); it != _pending_GlobalAchievementPercentagesReady_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GlobalAchievementPercentagesReady_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_GlobalStatsReceived_t.begin(); it != _pending_GlobalStatsReceived_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_GlobalStatsReceived_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_HTML_BrowserReady_t.begin(); it != _pending_HTML_BrowserReady_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_HTML_BrowserReady_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_JoinClanChatRoomCompletionResult_t.begin(); it != _pending_JoinClanChatRoomCompletionResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_JoinClanChatRoomCompletionResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_JoinPartyCallback_t.begin(); it != _pending_JoinPartyCallback_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_JoinPartyCallback_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LeaderboardFindResult_t.begin(); it != _pending_LeaderboardFindResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LeaderboardFindResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LeaderboardScoreUploaded_t.begin(); it != _pending_LeaderboardScoreUploaded_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LeaderboardScoreUploaded_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LeaderboardScoresDownloaded_t.begin(); it != _pending_LeaderboardScoresDownloaded_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LeaderboardScoresDownloaded_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LeaderboardUGCSet_t.begin(); it != _pending_LeaderboardUGCSet_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LeaderboardUGCSet_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LobbyCreated_t.begin(); it != _pending_LobbyCreated_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LobbyCreated_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LobbyEnter_t.begin(); it != _pending_LobbyEnter_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LobbyEnter_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_LobbyMatchList_t.begin(); it != _pending_LobbyMatchList_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_LobbyMatchList_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_MarketEligibilityResponse_t.begin(); it != _pending_MarketEligibilityResponse_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_MarketEligibilityResponse_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_NumberOfCurrentPlayers_t.begin(); it != _pending_NumberOfCurrentPlayers_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_NumberOfCurrentPlayers_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageDeletePublishedFileResult_t.begin(); it != _pending_RemoteStorageDeletePublishedFileResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageDeletePublishedFileResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageDownloadUGCResult_t.begin(); it != _pending_RemoteStorageDownloadUGCResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageDownloadUGCResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t.begin(); it != _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageEnumerateUserPublishedFilesResult_t.begin(); it != _pending_RemoteStorageEnumerateUserPublishedFilesResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageEnumerateUserPublishedFilesResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t.begin(); it != _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageEnumerateWorkshopFilesResult_t.begin(); it != _pending_RemoteStorageEnumerateWorkshopFilesResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageEnumerateWorkshopFilesResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageFileReadAsyncComplete_t.begin(); it != _pending_RemoteStorageFileReadAsyncComplete_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageFileReadAsyncComplete_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageFileShareResult_t.begin(); it != _pending_RemoteStorageFileShareResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageFileShareResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageFileWriteAsyncComplete_t.begin(); it != _pending_RemoteStorageFileWriteAsyncComplete_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageFileWriteAsyncComplete_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageGetPublishedFileDetailsResult_t.begin(); it != _pending_RemoteStorageGetPublishedFileDetailsResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageGetPublishedFileDetailsResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t.begin(); it != _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStoragePublishFileProgress_t.begin(); it != _pending_RemoteStoragePublishFileProgress_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStoragePublishFileProgress_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageSetUserPublishedFileActionResult_t.begin(); it != _pending_RemoteStorageSetUserPublishedFileActionResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageSetUserPublishedFileActionResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageSubscribePublishedFileResult_t.begin(); it != _pending_RemoteStorageSubscribePublishedFileResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageSubscribePublishedFileResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageUnsubscribePublishedFileResult_t.begin(); it != _pending_RemoteStorageUnsubscribePublishedFileResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageUnsubscribePublishedFileResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageUpdatePublishedFileResult_t.begin(); it != _pending_RemoteStorageUpdatePublishedFileResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageUpdatePublishedFileResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t.begin(); it != _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoveAppDependencyResult_t.begin(); it != _pending_RemoveAppDependencyResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoveAppDependencyResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_RemoveUGCDependencyResult_t.begin(); it != _pending_RemoveUGCDependencyResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_RemoveUGCDependencyResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SetUserItemVoteResult_t.begin(); it != _pending_SetUserItemVoteResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SetUserItemVoteResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_StartPlaytimeTrackingResult_t.begin(); it != _pending_StartPlaytimeTrackingResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_StartPlaytimeTrackingResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamInventoryEligiblePromoItemDefIDs_t.begin(); it != _pending_SteamInventoryEligiblePromoItemDefIDs_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamInventoryEligiblePromoItemDefIDs_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamInventoryRequestPricesResult_t.begin(); it != _pending_SteamInventoryRequestPricesResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamInventoryRequestPricesResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamInventoryStartPurchaseResult_t.begin(); it != _pending_SteamInventoryStartPurchaseResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamInventoryStartPurchaseResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamTimelineEventRecordingExists_t.begin(); it != _pending_SteamTimelineEventRecordingExists_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamTimelineEventRecordingExists_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamTimelineGamePhaseRecordingExists_t.begin(); it != _pending_SteamTimelineGamePhaseRecordingExists_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamTimelineGamePhaseRecordingExists_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamUGCQueryCompleted_t.begin(); it != _pending_SteamUGCQueryCompleted_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamUGCQueryCompleted_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SteamUGCRequestUGCDetailsResult_t.begin(); it != _pending_SteamUGCRequestUGCDetailsResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SteamUGCRequestUGCDetailsResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_StopPlaytimeTrackingResult_t.begin(); it != _pending_StopPlaytimeTrackingResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_StopPlaytimeTrackingResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_StoreAuthURLResponse_t.begin(); it != _pending_StoreAuthURLResponse_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_StoreAuthURLResponse_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_SubmitItemUpdateResult_t.begin(); it != _pending_SubmitItemUpdateResult_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_SubmitItemUpdateResult_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_UserFavoriteItemsListChanged_t.begin(); it != _pending_UserFavoriteItemsListChanged_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_UserFavoriteItemsListChanged_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_UserStatsReceived_t.begin(); it != _pending_UserStatsReceived_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_UserStatsReceived_t.erase(it);
    } else {
      ++it;
    }
  }
  for (auto it = _pending_WorkshopEULAStatus_t.begin(); it != _pending_WorkshopEULAStatus_t.end(); ) {
    if ((*it)->completed) {
      delete *it;
      it = _pending_WorkshopEULAStatus_t.erase(it);
    } else {
      ++it;
    }
  }
}

static void _cancel_all_pending_calls() {
  for (auto *p : _pending_AddAppDependencyResult_t) delete p;
  _pending_AddAppDependencyResult_t.clear();
  for (auto *p : _pending_AddUGCDependencyResult_t) delete p;
  _pending_AddUGCDependencyResult_t.clear();
  for (auto *p : _pending_AssociateWithClanResult_t) delete p;
  _pending_AssociateWithClanResult_t.clear();
  for (auto *p : _pending_ChangeNumOpenSlotsCallback_t) delete p;
  _pending_ChangeNumOpenSlotsCallback_t.clear();
  for (auto *p : _pending_CheckFileSignature_t) delete p;
  _pending_CheckFileSignature_t.clear();
  for (auto *p : _pending_ClanOfficerListResponse_t) delete p;
  _pending_ClanOfficerListResponse_t.clear();
  for (auto *p : _pending_ComputeNewPlayerCompatibilityResult_t) delete p;
  _pending_ComputeNewPlayerCompatibilityResult_t.clear();
  for (auto *p : _pending_CreateBeaconCallback_t) delete p;
  _pending_CreateBeaconCallback_t.clear();
  for (auto *p : _pending_CreateItemResult_t) delete p;
  _pending_CreateItemResult_t.clear();
  for (auto *p : _pending_DeleteItemResult_t) delete p;
  _pending_DeleteItemResult_t.clear();
  for (auto *p : _pending_DownloadClanActivityCountsResult_t) delete p;
  _pending_DownloadClanActivityCountsResult_t.clear();
  for (auto *p : _pending_DurationControl_t) delete p;
  _pending_DurationControl_t.clear();
  for (auto *p : _pending_EncryptedAppTicketResponse_t) delete p;
  _pending_EncryptedAppTicketResponse_t.clear();
  for (auto *p : _pending_EquippedProfileItems_t) delete p;
  _pending_EquippedProfileItems_t.clear();
  for (auto *p : _pending_FileDetailsResult_t) delete p;
  _pending_FileDetailsResult_t.clear();
  for (auto *p : _pending_FriendsEnumerateFollowingList_t) delete p;
  _pending_FriendsEnumerateFollowingList_t.clear();
  for (auto *p : _pending_FriendsGetFollowerCount_t) delete p;
  _pending_FriendsGetFollowerCount_t.clear();
  for (auto *p : _pending_FriendsIsFollowing_t) delete p;
  _pending_FriendsIsFollowing_t.clear();
  for (auto *p : _pending_GSReputation_t) delete p;
  _pending_GSReputation_t.clear();
  for (auto *p : _pending_GSStatsReceived_t) delete p;
  _pending_GSStatsReceived_t.clear();
  for (auto *p : _pending_GSStatsStored_t) delete p;
  _pending_GSStatsStored_t.clear();
  for (auto *p : _pending_GetAppDependenciesResult_t) delete p;
  _pending_GetAppDependenciesResult_t.clear();
  for (auto *p : _pending_GetUserItemVoteResult_t) delete p;
  _pending_GetUserItemVoteResult_t.clear();
  for (auto *p : _pending_GlobalAchievementPercentagesReady_t) delete p;
  _pending_GlobalAchievementPercentagesReady_t.clear();
  for (auto *p : _pending_GlobalStatsReceived_t) delete p;
  _pending_GlobalStatsReceived_t.clear();
  for (auto *p : _pending_HTML_BrowserReady_t) delete p;
  _pending_HTML_BrowserReady_t.clear();
  for (auto *p : _pending_JoinClanChatRoomCompletionResult_t) delete p;
  _pending_JoinClanChatRoomCompletionResult_t.clear();
  for (auto *p : _pending_JoinPartyCallback_t) delete p;
  _pending_JoinPartyCallback_t.clear();
  for (auto *p : _pending_LeaderboardFindResult_t) delete p;
  _pending_LeaderboardFindResult_t.clear();
  for (auto *p : _pending_LeaderboardScoreUploaded_t) delete p;
  _pending_LeaderboardScoreUploaded_t.clear();
  for (auto *p : _pending_LeaderboardScoresDownloaded_t) delete p;
  _pending_LeaderboardScoresDownloaded_t.clear();
  for (auto *p : _pending_LeaderboardUGCSet_t) delete p;
  _pending_LeaderboardUGCSet_t.clear();
  for (auto *p : _pending_LobbyCreated_t) delete p;
  _pending_LobbyCreated_t.clear();
  for (auto *p : _pending_LobbyEnter_t) delete p;
  _pending_LobbyEnter_t.clear();
  for (auto *p : _pending_LobbyMatchList_t) delete p;
  _pending_LobbyMatchList_t.clear();
  for (auto *p : _pending_MarketEligibilityResponse_t) delete p;
  _pending_MarketEligibilityResponse_t.clear();
  for (auto *p : _pending_NumberOfCurrentPlayers_t) delete p;
  _pending_NumberOfCurrentPlayers_t.clear();
  for (auto *p : _pending_RemoteStorageDeletePublishedFileResult_t) delete p;
  _pending_RemoteStorageDeletePublishedFileResult_t.clear();
  for (auto *p : _pending_RemoteStorageDownloadUGCResult_t) delete p;
  _pending_RemoteStorageDownloadUGCResult_t.clear();
  for (auto *p : _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t) delete p;
  _pending_RemoteStorageEnumeratePublishedFilesByUserActionResult_t.clear();
  for (auto *p : _pending_RemoteStorageEnumerateUserPublishedFilesResult_t) delete p;
  _pending_RemoteStorageEnumerateUserPublishedFilesResult_t.clear();
  for (auto *p : _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t) delete p;
  _pending_RemoteStorageEnumerateUserSubscribedFilesResult_t.clear();
  for (auto *p : _pending_RemoteStorageEnumerateWorkshopFilesResult_t) delete p;
  _pending_RemoteStorageEnumerateWorkshopFilesResult_t.clear();
  for (auto *p : _pending_RemoteStorageFileReadAsyncComplete_t) delete p;
  _pending_RemoteStorageFileReadAsyncComplete_t.clear();
  for (auto *p : _pending_RemoteStorageFileShareResult_t) delete p;
  _pending_RemoteStorageFileShareResult_t.clear();
  for (auto *p : _pending_RemoteStorageFileWriteAsyncComplete_t) delete p;
  _pending_RemoteStorageFileWriteAsyncComplete_t.clear();
  for (auto *p : _pending_RemoteStorageGetPublishedFileDetailsResult_t) delete p;
  _pending_RemoteStorageGetPublishedFileDetailsResult_t.clear();
  for (auto *p : _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t) delete p;
  _pending_RemoteStorageGetPublishedItemVoteDetailsResult_t.clear();
  for (auto *p : _pending_RemoteStoragePublishFileProgress_t) delete p;
  _pending_RemoteStoragePublishFileProgress_t.clear();
  for (auto *p : _pending_RemoteStorageSetUserPublishedFileActionResult_t) delete p;
  _pending_RemoteStorageSetUserPublishedFileActionResult_t.clear();
  for (auto *p : _pending_RemoteStorageSubscribePublishedFileResult_t) delete p;
  _pending_RemoteStorageSubscribePublishedFileResult_t.clear();
  for (auto *p : _pending_RemoteStorageUnsubscribePublishedFileResult_t) delete p;
  _pending_RemoteStorageUnsubscribePublishedFileResult_t.clear();
  for (auto *p : _pending_RemoteStorageUpdatePublishedFileResult_t) delete p;
  _pending_RemoteStorageUpdatePublishedFileResult_t.clear();
  for (auto *p : _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t) delete p;
  _pending_RemoteStorageUpdateUserPublishedItemVoteResult_t.clear();
  for (auto *p : _pending_RemoveAppDependencyResult_t) delete p;
  _pending_RemoveAppDependencyResult_t.clear();
  for (auto *p : _pending_RemoveUGCDependencyResult_t) delete p;
  _pending_RemoveUGCDependencyResult_t.clear();
  for (auto *p : _pending_SetUserItemVoteResult_t) delete p;
  _pending_SetUserItemVoteResult_t.clear();
  for (auto *p : _pending_StartPlaytimeTrackingResult_t) delete p;
  _pending_StartPlaytimeTrackingResult_t.clear();
  for (auto *p : _pending_SteamInventoryEligiblePromoItemDefIDs_t) delete p;
  _pending_SteamInventoryEligiblePromoItemDefIDs_t.clear();
  for (auto *p : _pending_SteamInventoryRequestPricesResult_t) delete p;
  _pending_SteamInventoryRequestPricesResult_t.clear();
  for (auto *p : _pending_SteamInventoryStartPurchaseResult_t) delete p;
  _pending_SteamInventoryStartPurchaseResult_t.clear();
  for (auto *p : _pending_SteamTimelineEventRecordingExists_t) delete p;
  _pending_SteamTimelineEventRecordingExists_t.clear();
  for (auto *p : _pending_SteamTimelineGamePhaseRecordingExists_t) delete p;
  _pending_SteamTimelineGamePhaseRecordingExists_t.clear();
  for (auto *p : _pending_SteamUGCQueryCompleted_t) delete p;
  _pending_SteamUGCQueryCompleted_t.clear();
  for (auto *p : _pending_SteamUGCRequestUGCDetailsResult_t) delete p;
  _pending_SteamUGCRequestUGCDetailsResult_t.clear();
  for (auto *p : _pending_StopPlaytimeTrackingResult_t) delete p;
  _pending_StopPlaytimeTrackingResult_t.clear();
  for (auto *p : _pending_StoreAuthURLResponse_t) delete p;
  _pending_StoreAuthURLResponse_t.clear();
  for (auto *p : _pending_SubmitItemUpdateResult_t) delete p;
  _pending_SubmitItemUpdateResult_t.clear();
  for (auto *p : _pending_UserFavoriteItemsListChanged_t) delete p;
  _pending_UserFavoriteItemsListChanged_t.clear();
  for (auto *p : _pending_UserStatsReceived_t) delete p;
  _pending_UserStatsReceived_t.clear();
  for (auto *p : _pending_WorkshopEULAStatus_t) delete p;
  _pending_WorkshopEULAStatus_t.clear();
}

// ============================================================
// Panda3D messenger integration
// ============================================================

static PyObject *_py_messenger = nullptr;

static void _ensure_messenger() {
  if (_py_messenger) return;
  PyObject *mod = PyImport_ImportModule("direct.showbase.MessengerGlobal");
  if (!mod) { PyErr_Print(); return; }
  _py_messenger = PyObject_GetAttrString(mod, "messenger");
  Py_DECREF(mod);
  if (!_py_messenger) PyErr_Print();
}

static void _send_event(const char *name, PyObject *dict) {
  _ensure_messenger();
  if (!_py_messenger) return;
  PyObject *args_list = PyList_New(1);
  Py_INCREF(dict);
  PyList_SET_ITEM(args_list, 0, dict);
  PyObject *ret = PyObject_CallMethod(_py_messenger, "send", "sO", name, args_list);
  if (!ret) PyErr_Print();
  Py_XDECREF(ret);
  Py_DECREF(args_list);
}

// ============================================================
// Broadcast callback handler
// ============================================================

class _BroadcastHandler {
public:
  _BroadcastHandler() :
    _cb_DlcInstalled_t(this, &_BroadcastHandler::_On_DlcInstalled_t),
    _cb_GameLobbyJoinRequested_t(this, &_BroadcastHandler::_On_GameLobbyJoinRequested_t),
    _cb_GameOverlayActivated_t(this, &_BroadcastHandler::_On_GameOverlayActivated_t),
    _cb_GetAuthSessionTicketResponse_t(this, &_BroadcastHandler::_On_GetAuthSessionTicketResponse_t),
    _cb_ItemInstalled_t(this, &_BroadcastHandler::_On_ItemInstalled_t),
    _cb_LicensesUpdated_t(this, &_BroadcastHandler::_On_LicensesUpdated_t),
    _cb_LobbyChatUpdate_t(this, &_BroadcastHandler::_On_LobbyChatUpdate_t),
    _cb_LobbyDataUpdate_t(this, &_BroadcastHandler::_On_LobbyDataUpdate_t),
    _cb_LobbyGameCreated_t(this, &_BroadcastHandler::_On_LobbyGameCreated_t),
    _cb_LobbyInvite_t(this, &_BroadcastHandler::_On_LobbyInvite_t),
    _cb_MicroTxnAuthorizationResponse_t(this, &_BroadcastHandler::_On_MicroTxnAuthorizationResponse_t),
    _cb_NewUrlLaunchParameters_t(this, &_BroadcastHandler::_On_NewUrlLaunchParameters_t),
    _cb_PersonaStateChange_t(this, &_BroadcastHandler::_On_PersonaStateChange_t),
    _cb_ScreenshotReady_t(this, &_BroadcastHandler::_On_ScreenshotReady_t),
    _cb_ScreenshotRequested_t(this, &_BroadcastHandler::_On_ScreenshotRequested_t),
    _cb_SteamServerConnectFailure_t(this, &_BroadcastHandler::_On_SteamServerConnectFailure_t),
    _cb_SteamServersConnected_t(this, &_BroadcastHandler::_On_SteamServersConnected_t),
    _cb_SteamServersDisconnected_t(this, &_BroadcastHandler::_On_SteamServersDisconnected_t),
    _cb_UserAchievementStored_t(this, &_BroadcastHandler::_On_UserAchievementStored_t),
    _cb_UserStatsStored_t(this, &_BroadcastHandler::_On_UserStatsStored_t),
    _cb_ValidateAuthTicketResponse_t(this, &_BroadcastHandler::_On_ValidateAuthTicketResponse_t)
  {}

  void _On_DlcInstalled_t(DlcInstalled_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_nAppID));
    PyDict_SetItemString(dict, "app_id", val);
    Py_DECREF(val);
    _send_event("Steam-DlcInstalled", dict);
    Py_DECREF(dict);
  }

  void _On_GameLobbyJoinRequested_t(GameLobbyJoinRequested_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((pParam->m_steamIDLobby).ConvertToUint64());
    PyDict_SetItemString(dict, "steam_id_lobby", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((pParam->m_steamIDFriend).ConvertToUint64());
    PyDict_SetItemString(dict, "steam_id_friend", val);
    Py_DECREF(val);
    _send_event("Steam-GameLobbyJoinRequested", dict);
    Py_DECREF(dict);
  }

  void _On_GameOverlayActivated_t(GameOverlayActivated_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromLong((long)(pParam->m_bActive));
    PyDict_SetItemString(dict, "active", val);
    Py_DECREF(val);
    val = PyBool_FromLong((long)(pParam->m_bUserInitiated));
    PyDict_SetItemString(dict, "user_initiated", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_nAppID));
    PyDict_SetItemString(dict, "app_id", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_dwOverlayPID));
    PyDict_SetItemString(dict, "dw_overlay_pid", val);
    Py_DECREF(val);
    _send_event("Steam-GameOverlayActivated", dict);
    Py_DECREF(dict);
  }

  void _On_GetAuthSessionTicketResponse_t(GetAuthSessionTicketResponse_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_hAuthTicket));
    PyDict_SetItemString(dict, "auth_ticket", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_eResult));
    PyDict_SetItemString(dict, "result", val);
    Py_DECREF(val);
    _send_event("Steam-GetAuthSessionTicketResponse", dict);
    Py_DECREF(dict);
  }

  void _On_ItemInstalled_t(ItemInstalled_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_unAppID));
    PyDict_SetItemString(dict, "app_id", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_nPublishedFileId));
    PyDict_SetItemString(dict, "published_file_id", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_hLegacyContent));
    PyDict_SetItemString(dict, "legacy_content", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_unManifestID));
    PyDict_SetItemString(dict, "manifest_id", val);
    Py_DECREF(val);
    _send_event("Steam-ItemInstalled", dict);
    Py_DECREF(dict);
  }

  void _On_LicensesUpdated_t(LicensesUpdated_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    _send_event("Steam-LicensesUpdated", dict);
    Py_DECREF(dict);
  }

  void _On_LobbyChatUpdate_t(LobbyChatUpdate_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDLobby));
    PyDict_SetItemString(dict, "steam_id_lobby", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDUserChanged));
    PyDict_SetItemString(dict, "steam_id_user_changed", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDMakingChange));
    PyDict_SetItemString(dict, "steam_id_making_change", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_rgfChatMemberStateChange));
    PyDict_SetItemString(dict, "chat_member_state_change", val);
    Py_DECREF(val);
    _send_event("Steam-LobbyChatUpdate", dict);
    Py_DECREF(dict);
  }

  void _On_LobbyDataUpdate_t(LobbyDataUpdate_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDLobby));
    PyDict_SetItemString(dict, "steam_id_lobby", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDMember));
    PyDict_SetItemString(dict, "steam_id_member", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_bSuccess));
    PyDict_SetItemString(dict, "success", val);
    Py_DECREF(val);
    _send_event("Steam-LobbyDataUpdate", dict);
    Py_DECREF(dict);
  }

  void _On_LobbyGameCreated_t(LobbyGameCreated_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDLobby));
    PyDict_SetItemString(dict, "steam_id_lobby", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDGameServer));
    PyDict_SetItemString(dict, "steam_id_game_server", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_unIP));
    PyDict_SetItemString(dict, "ip", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_usPort));
    PyDict_SetItemString(dict, "us_port", val);
    Py_DECREF(val);
    _send_event("Steam-LobbyGameCreated", dict);
    Py_DECREF(dict);
  }

  void _On_LobbyInvite_t(LobbyInvite_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDUser));
    PyDict_SetItemString(dict, "steam_id_user", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamIDLobby));
    PyDict_SetItemString(dict, "steam_id_lobby", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulGameID));
    PyDict_SetItemString(dict, "game_id", val);
    Py_DECREF(val);
    _send_event("Steam-LobbyInvite", dict);
    Py_DECREF(dict);
  }

  void _On_MicroTxnAuthorizationResponse_t(MicroTxnAuthorizationResponse_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_unAppID));
    PyDict_SetItemString(dict, "app_id", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulOrderID));
    PyDict_SetItemString(dict, "order_id", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_bAuthorized));
    PyDict_SetItemString(dict, "authorized", val);
    Py_DECREF(val);
    _send_event("Steam-MicroTxnAuthorizationResponse", dict);
    Py_DECREF(dict);
  }

  void _On_NewUrlLaunchParameters_t(NewUrlLaunchParameters_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    _send_event("Steam-NewUrlLaunchParameters", dict);
    Py_DECREF(dict);
  }

  void _On_PersonaStateChange_t(PersonaStateChange_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_ulSteamID));
    PyDict_SetItemString(dict, "steam_id", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_nChangeFlags));
    PyDict_SetItemString(dict, "change_flags", val);
    Py_DECREF(val);
    _send_event("Steam-PersonaStateChange", dict);
    Py_DECREF(dict);
  }

  void _On_ScreenshotReady_t(ScreenshotReady_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_hLocal));
    PyDict_SetItemString(dict, "local", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_eResult));
    PyDict_SetItemString(dict, "result", val);
    Py_DECREF(val);
    _send_event("Steam-ScreenshotReady", dict);
    Py_DECREF(dict);
  }

  void _On_ScreenshotRequested_t(ScreenshotRequested_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    _send_event("Steam-ScreenshotRequested", dict);
    Py_DECREF(dict);
  }

  void _On_SteamServerConnectFailure_t(SteamServerConnectFailure_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromLong((long)(pParam->m_eResult));
    PyDict_SetItemString(dict, "result", val);
    Py_DECREF(val);
    val = PyBool_FromLong((long)(pParam->m_bStillRetrying));
    PyDict_SetItemString(dict, "still_retrying", val);
    Py_DECREF(val);
    _send_event("Steam-SteamServerConnectFailure", dict);
    Py_DECREF(dict);
  }

  void _On_SteamServersConnected_t(SteamServersConnected_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    _send_event("Steam-SteamServersConnected", dict);
    Py_DECREF(dict);
  }

  void _On_SteamServersDisconnected_t(SteamServersDisconnected_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromLong((long)(pParam->m_eResult));
    PyDict_SetItemString(dict, "result", val);
    Py_DECREF(val);
    _send_event("Steam-SteamServersDisconnected", dict);
    Py_DECREF(dict);
  }

  void _On_UserAchievementStored_t(UserAchievementStored_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_nGameID));
    PyDict_SetItemString(dict, "game_id", val);
    Py_DECREF(val);
    val = PyBool_FromLong((long)(pParam->m_bGroupAchievement));
    PyDict_SetItemString(dict, "group_achievement", val);
    Py_DECREF(val);
    val = PyUnicode_FromString(pParam->m_rgchAchievementName);
    PyDict_SetItemString(dict, "rgch_achievement_name", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_nCurProgress));
    PyDict_SetItemString(dict, "cur_progress", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLong((unsigned long)(pParam->m_nMaxProgress));
    PyDict_SetItemString(dict, "max_progress", val);
    Py_DECREF(val);
    _send_event("Steam-UserAchievementStored", dict);
    Py_DECREF(dict);
  }

  void _On_UserStatsStored_t(UserStatsStored_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((unsigned long long)(pParam->m_nGameID));
    PyDict_SetItemString(dict, "game_id", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_eResult));
    PyDict_SetItemString(dict, "result", val);
    Py_DECREF(val);
    _send_event("Steam-UserStatsStored", dict);
    Py_DECREF(dict);
  }

  void _On_ValidateAuthTicketResponse_t(ValidateAuthTicketResponse_t *pParam) {
    PyObject *dict = PyDict_New();
    PyObject *val;
    val = PyLong_FromUnsignedLongLong((pParam->m_SteamID).ConvertToUint64());
    PyDict_SetItemString(dict, "steam_id", val);
    Py_DECREF(val);
    val = PyLong_FromLong((long)(pParam->m_eAuthSessionResponse));
    PyDict_SetItemString(dict, "auth_session_response", val);
    Py_DECREF(val);
    val = PyLong_FromUnsignedLongLong((pParam->m_OwnerSteamID).ConvertToUint64());
    PyDict_SetItemString(dict, "owner_steam_id", val);
    Py_DECREF(val);
    _send_event("Steam-ValidateAuthTicketResponse", dict);
    Py_DECREF(dict);
  }

private:
  CCallback<_BroadcastHandler, DlcInstalled_t, false> _cb_DlcInstalled_t;
  CCallback<_BroadcastHandler, GameLobbyJoinRequested_t, false> _cb_GameLobbyJoinRequested_t;
  CCallback<_BroadcastHandler, GameOverlayActivated_t, false> _cb_GameOverlayActivated_t;
  CCallback<_BroadcastHandler, GetAuthSessionTicketResponse_t, false> _cb_GetAuthSessionTicketResponse_t;
  CCallback<_BroadcastHandler, ItemInstalled_t, false> _cb_ItemInstalled_t;
  CCallback<_BroadcastHandler, LicensesUpdated_t, false> _cb_LicensesUpdated_t;
  CCallback<_BroadcastHandler, LobbyChatUpdate_t, false> _cb_LobbyChatUpdate_t;
  CCallback<_BroadcastHandler, LobbyDataUpdate_t, false> _cb_LobbyDataUpdate_t;
  CCallback<_BroadcastHandler, LobbyGameCreated_t, false> _cb_LobbyGameCreated_t;
  CCallback<_BroadcastHandler, LobbyInvite_t, false> _cb_LobbyInvite_t;
  CCallback<_BroadcastHandler, MicroTxnAuthorizationResponse_t, false> _cb_MicroTxnAuthorizationResponse_t;
  CCallback<_BroadcastHandler, NewUrlLaunchParameters_t, false> _cb_NewUrlLaunchParameters_t;
  CCallback<_BroadcastHandler, PersonaStateChange_t, false> _cb_PersonaStateChange_t;
  CCallback<_BroadcastHandler, ScreenshotReady_t, false> _cb_ScreenshotReady_t;
  CCallback<_BroadcastHandler, ScreenshotRequested_t, false> _cb_ScreenshotRequested_t;
  CCallback<_BroadcastHandler, SteamServerConnectFailure_t, false> _cb_SteamServerConnectFailure_t;
  CCallback<_BroadcastHandler, SteamServersConnected_t, false> _cb_SteamServersConnected_t;
  CCallback<_BroadcastHandler, SteamServersDisconnected_t, false> _cb_SteamServersDisconnected_t;
  CCallback<_BroadcastHandler, UserAchievementStored_t, false> _cb_UserAchievementStored_t;
  CCallback<_BroadcastHandler, UserStatsStored_t, false> _cb_UserStatsStored_t;
  CCallback<_BroadcastHandler, ValidateAuthTicketResponse_t, false> _cb_ValidateAuthTicketResponse_t;
};

static _BroadcastHandler *_g_broadcast_handler = nullptr;

// ============================================================
// SteamCallbackManager implementation
// ============================================================

void SteamCallbackManager::run_callbacks() {
  if (!_g_broadcast_handler) {
    _g_broadcast_handler = new _BroadcastHandler();
  }
  SteamAPI_RunCallbacks();
  _cleanup_completed_calls();
}

void SteamCallbackManager::shutdown() {
  delete _g_broadcast_handler;
  _g_broadcast_handler = nullptr;
  Py_XDECREF(_py_messenger);
  _py_messenger = nullptr;
  _cancel_all_pending_calls();
}

#endif  // CPPPARSER
